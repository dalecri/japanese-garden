<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Voxel Task Garden</title>
<style>
*,*::before,*::after{box-sizing:border-box}
body{margin:0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif;background:#00001a;overflow:hidden;-webkit-tap-highlight-color:transparent;user-select:none}
#c{display:block;width:100vw;height:100vh}

/* â”€â”€ Floating labels (CSS2DRenderer â€” z-index 6 fixes the click-through bug) â”€â”€ */
.tree-label{display:flex;flex-direction:column;align-items:center;pointer-events:none;transform:translateY(-8px)}
.tree-label-bubble{background:rgba(15,10,35,.88);border:1.5px solid rgba(246,135,179,.65);color:#fff;padding:4px 10px;border-radius:20px;font-size:11px;font-weight:600;white-space:nowrap;max-width:160px;overflow:hidden;text-overflow:ellipsis;backdrop-filter:blur(6px);box-shadow:0 2px 14px rgba(246,135,179,.3);pointer-events:none;transition:all .2s;display:flex;align-items:center;gap:5px}
.tree-label-bubble.selected{background:rgba(246,135,179,.92);border-color:#fff;box-shadow:0 0 22px rgba(246,135,179,.9);transform:scale(1.08)}
.priority-dot{width:7px;height:7px;border-radius:50%;flex-shrink:0}
.priority-low .priority-dot{background:#6ee7b7}
.priority-med .priority-dot{background:#fbbf24}
.priority-high .priority-dot{background:#f87171}
.tree-label-stem{width:2px;height:10px;background:rgba(246,135,179,.45)}
.tree-label-confirm{display:none;background:#22c55e;color:#fff;border:none;padding:6px 14px;border-radius:20px;font-size:12px;font-weight:700;margin-top:5px;cursor:pointer;pointer-events:all;box-shadow:0 2px 12px rgba(34,197,94,.55);white-space:nowrap}
.tree-label.selected .tree-label-confirm{display:block}
.tree-label.selected .tree-label-bubble{pointer-events:all;cursor:pointer}

/* â”€â”€ Top UI â”€â”€ */
#task-counter-container{position:fixed;top:16px;right:16px;z-index:20}
#task-counter{background:rgba(255,255,255,.1);padding:10px 14px;border-radius:12px;color:#fff;font-size:13px;font-weight:600;border:1px solid rgba(255,255,255,.2);cursor:pointer;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);white-space:nowrap;transition:background .2s}
#task-counter:hover,#task-counter:active{background:rgba(255,255,255,.22)}
#time-badge{position:fixed;top:16px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);color:rgba(255,255,255,.85);padding:5px 14px;border-radius:20px;font-size:12px;font-weight:600;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);z-index:20;pointer-events:none;letter-spacing:.03em;white-space:nowrap}
#season-badge{position:fixed;top:52px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.28);border:1px solid rgba(255,255,255,.08);color:rgba(255,255,255,.7);padding:3px 12px;border-radius:20px;font-size:11px;font-weight:600;z-index:20;pointer-events:none;white-space:nowrap}
#sound-btn{position:fixed;top:16px;left:16px;z-index:20;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.18);color:#fff;width:38px;height:38px;border-radius:50%;font-size:16px;cursor:pointer;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);transition:background .2s;display:flex;align-items:center;justify-content:center}
#sound-btn:hover,#sound-btn:active{background:rgba(255,255,255,.22)}
#vol-widget{position:fixed;top:18px;left:62px;z-index:20;display:flex;align-items:center;background:rgba(10,8,28,.72);border:1px solid rgba(255,255,255,.13);border-radius:999px;padding:0 12px;height:34px;backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);box-shadow:0 4px 16px rgba(0,0,0,.35);opacity:0;pointer-events:none;transition:opacity .3s}
#vol-widget.visible{opacity:1;pointer-events:all}
#vol-widget.dimmed{opacity:0.3}
@media(max-width:600px){#vol-widget{top:64px;left:16px;}}
#vol-slider{-webkit-appearance:none;appearance:none;width:80px;height:3px;border-radius:99px;background:rgba(255,255,255,.2);outline:none;cursor:pointer}
#vol-slider::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;border-radius:50%;background:#f687b3;cursor:pointer;box-shadow:0 0 6px rgba(246,135,179,.6)}
#vol-slider::-moz-range-thumb{width:14px;height:14px;border-radius:50%;background:#f687b3;cursor:pointer;border:none}

/* â”€â”€ Bottom sheet â”€â”€ */
#bottom-sheet{position:fixed;bottom:0;left:0;right:0;z-index:30;background:rgba(12,10,34,.97);border-top:1px solid rgba(255,255,255,.1);border-radius:20px 20px 0 0;transform:translateY(100%);transition:transform .35s cubic-bezier(.32,.72,0,1);max-height:72vh;display:flex;flex-direction:column;backdrop-filter:blur(16px);-webkit-backdrop-filter:blur(16px)}
#bottom-sheet.open{transform:translateY(0)}
.sheet-handle{width:40px;height:4px;background:rgba(255,255,255,.22);border-radius:2px;margin:12px auto 0;flex-shrink:0}
.sheet-header{display:flex;align-items:center;padding:12px 20px 6px;flex-shrink:0}
.sheet-title{color:#fff;font-size:16px;font-weight:700;flex:1}
.sheet-close{background:rgba(255,255,255,.1);border:none;color:#fff;width:30px;height:30px;border-radius:50%;font-size:15px;cursor:pointer;display:flex;align-items:center;justify-content:center}
.overlay-tabs{display:flex;border-bottom:1px solid rgba(255,255,255,.08);flex-shrink:0;padding:0 20px}
.tab-btn{flex:1;padding:10px 0;background:transparent;border:none;color:#777;cursor:pointer;font-size:13px;font-weight:600;border-bottom:2px solid transparent;transition:.2s}
.tab-btn.active{color:#f687b3;border-bottom-color:#f687b3}
.tab-content{padding:10px 20px 24px;overflow-y:auto;-webkit-overflow-scrolling:touch;flex:1}
.task-list-item{color:#fff;padding:12px 0;border-bottom:1px solid rgba(255,255,255,.06);display:flex;align-items:center;gap:10px}
.task-dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}
.task-dot.low{background:#6ee7b7}.task-dot.med{background:#fbbf24}.task-dot.high{background:#f87171}
.task-list-item.completed .task-dot{background:#444}
.task-list-item.completed{color:#555;text-decoration:line-through;opacity:.7}
.task-list-item:last-child{border-bottom:none}
.task-item-inner{flex:1}
.task-item-inner .name{font-weight:600;font-size:14px}
.task-item-inner .meta{font-size:11px;color:#666;margin-top:3px;display:flex;gap:8px}
.priority-badge{font-size:10px;font-weight:700;padding:1px 7px;border-radius:10px}
.priority-badge.low{background:rgba(110,231,183,.2);color:#6ee7b7}
.priority-badge.med{background:rgba(251,191,36,.2);color:#fbbf24}
.priority-badge.high{background:rgba(248,113,113,.2);color:#f87171}
.empty-state{color:#555;font-size:13px;text-align:center;padding:32px 0}

/* â”€â”€ Bottom input bar â”€â”€ */
#input-bar{
  position:fixed;
  bottom:24px;
  left:50%;
  transform:translateX(-50%);
  z-index:25;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:7px;
  pointer-events:none;
  transition:opacity .35s, transform .35s cubic-bezier(.32,.72,0,1);
}
#input-bar.hidden{opacity:0;transform:translateX(-50%) translateY(20px);pointer-events:none}
/* Skin selector row */
.skin-row{
  display:flex;
  gap:5px;
  align-items:center;
  pointer-events:all;
}
.skin-btn{
  background:rgba(10,8,28,.65);
  border:1px solid rgba(255,255,255,.14);
  color:rgba(255,255,255,.45);
  padding:3px 10px;
  border-radius:20px;
  font-size:11px;
  font-weight:600;
  cursor:pointer;
  transition:all .18s;
  backdrop-filter:blur(10px);
  -webkit-backdrop-filter:blur(10px);
  pointer-events:all;
  white-space:nowrap;
}
.skin-btn:hover{background:rgba(255,255,255,.1);color:#fff}
.skin-btn.active{background:rgba(216,180,254,.18);border-color:#d8b4fe;color:#d8b4fe;box-shadow:0 0 8px rgba(216,180,254,.25)}
/* Priority tags row â€” above the pill */
.priority-row{
  display:flex;
  gap:5px;
  align-items:center;
  pointer-events:all;
}
.priority-label{display:none}
.pri-btn{
  background:rgba(10,8,28,.72);
  border:1px solid rgba(255,255,255,.18);
  color:rgba(255,255,255,.5);
  padding:4px 11px;
  border-radius:20px;
  font-size:11px;
  font-weight:700;
  cursor:pointer;
  transition:all .18s;
  white-space:nowrap;
  backdrop-filter:blur(10px);
  -webkit-backdrop-filter:blur(10px);
  letter-spacing:.3px;
  pointer-events:all;
}
.pri-btn:hover{background:rgba(255,255,255,.1);color:#fff}
.pri-btn.active-low{background:rgba(110,231,183,.18);border-color:#6ee7b7;color:#6ee7b7;box-shadow:0 0 10px rgba(110,231,183,.25)}
.pri-btn.active-med{background:rgba(251,191,36,.18);border-color:#fbbf24;color:#fbbf24;box-shadow:0 0 10px rgba(251,191,36,.25)}
.pri-btn.active-high{background:rgba(248,113,113,.18);border-color:#f87171;color:#f87171;box-shadow:0 0 10px rgba(248,113,113,.25)}
/* Main floating pill */
#input-row{
  display:flex;
  gap:8px;
  align-items:center;
  background:rgba(10,8,28,.78);
  border:1px solid rgba(255,255,255,.13);
  border-radius:999px;
  padding:7px 7px 7px 18px;
  backdrop-filter:blur(18px);
  -webkit-backdrop-filter:blur(18px);
  box-shadow:0 8px 32px rgba(0,0,0,.45), 0 0 0 1px rgba(255,255,255,.06) inset;
  pointer-events:all;
  min-width:280px;
  max-width:min(420px, calc(100vw - 32px));
}
#taskInput{
  flex:1;
  background:transparent;
  border:none;
  color:#fff;
  font-size:15px;
  outline:none;
  min-width:0;
}
#taskInput::placeholder{color:rgba(255,255,255,.3)}
#plantBtn{
  background:#f687b3;
  color:#fff;
  border:none;
  padding:9px 16px;
  border-radius:999px;
  font-size:14px;
  font-weight:700;
  cursor:pointer;
  flex-shrink:0;
  transition:background .15s,transform .1s;
  white-space:nowrap;
}
#plantBtn:active{background:#ed64a6;transform:scale(.95)}

/* â”€â”€ Hint â”€â”€ */
#hint{position:fixed;bottom:110px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.65);color:rgba(255,255,255,.75);padding:7px 16px;border-radius:20px;font-size:12px;z-index:15;pointer-events:none;transition:opacity .5s;white-space:nowrap}
#hint.hidden{opacity:0}

/* â”€â”€ Deselect overlay â€” z-index 4 so label renderer (z-index 6) is always above it â”€â”€ */
#deselect-overlay{display:none;position:fixed;inset:0;z-index:4}
#deselect-overlay.active{display:block}
</style>
</head>
<body>
<canvas id="c"></canvas>

<button id="sound-btn" title="Toggle ambient sound">ğŸ”‡</button>
<div id="task-counter-container"><div id="task-counter">ğŸŒ¸ 0 Tasks</div></div>
<div id="time-badge"></div>
<div id="season-badge"></div>

<div id="bottom-sheet">
  <div class="sheet-handle"></div>
  <div class="sheet-header">
    <span class="sheet-title">Task Garden</span>
    <button class="sheet-close" id="sheet-close">âœ•</button>
  </div>
  <div class="overlay-tabs">
    <button class="tab-btn active" id="btn-active">Active</button>
    <button class="tab-btn" id="btn-history">Completed</button>
  </div>
  <div id="tab-content" class="tab-content"></div>
</div>

<div id="deselect-overlay"></div>

<div id="input-bar">
  <div class="skin-row">
    <button class="skin-btn active" data-skin="blossom">ğŸŒ¸ Blossom</button>
    <button class="skin-btn" data-skin="jacaranda">ğŸ’œ Jacaranda</button>
    <button class="skin-btn" data-skin="pine">ğŸŒ² Pine</button>
    <button class="skin-btn" data-skin="maple">ğŸ Maple</button>
  </div>
  <div class="priority-row">
    <button class="pri-btn" id="pri-low">ğŸŸ¢ Low</button>
    <button class="pri-btn active-med" id="pri-med">ğŸŸ¡ Med</button>
    <button class="pri-btn" id="pri-high">ğŸ”´ High</button>
  </div>
  <div id="input-row">
    <input type="text" id="taskInput" placeholder="Name your taskâ€¦" autocomplete="off" autocorrect="off" spellcheck="false">
    <button id="plantBtn">ğŸŒ± Plant</button>
  </div>
</div>

<div id="hint">Tap a tree to select Â· tap âœ“ to complete</div>

<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/controls/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/","three/addons/renderers/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/renderers/"}}</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls }       from 'three/addons/controls/OrbitControls.js';
import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

const isMobile = () => window.innerWidth <= 768 || ('ontouchstart' in window);

// â”€â”€ Renderers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.querySelector('#c');
const renderer = new THREE.WebGLRenderer({ antialias: window.devicePixelRatio < 2, canvas, powerPreference:'high-performance' });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type    = THREE.PCFShadowMap; // cheaper than PCFSoft, still good
renderer.toneMapping       = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 0.9;

// FIX: z-index 6 > deselect-overlay (z-index 4) so label clicks are never blocked
const labelRenderer = new CSS2DRenderer();
labelRenderer.setSize(window.innerWidth, window.innerHeight);
Object.assign(labelRenderer.domElement.style, {
  position:'absolute', top:'0', left:'0', pointerEvents:'none', zIndex:'6'
});
document.body.appendChild(labelRenderer.domElement);

// â”€â”€ Scene â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const scene = new THREE.Scene();
scene.background = new THREE.Color('#00001a');
scene.fog = new THREE.FogExp2('#00001a', 0.006);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 25, 60);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.05;
controls.maxPolarAngle = Math.PI/1.9; controls.target.set(0, 8, 0);
controls.rotateSpeed = isMobile() ? 0.5 : 1.0;
controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_ROTATE };
controls.minDistance = 12;
controls.maxDistance = 180;
controls.enableZoom = true;
controls.zoomSpeed = 0.25;  // gentle on desktop; pinch works naturally on mobile

// â”€â”€ Lighting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const hemiLight    = new THREE.HemisphereLight(0x1a1a4e, 0x0d1a0d, 1.2); scene.add(hemiLight);
const ambientLight = new THREE.AmbientLight(0x4060a0, 0.8); scene.add(ambientLight);
const keyLight     = new THREE.DirectionalLight(0xc8d8ff, 2.2);
keyLight.castShadow = true;
keyLight.shadow.mapSize.width = keyLight.shadow.mapSize.height = 1024;
Object.assign(keyLight.shadow.camera, {top:70,bottom:-70,left:-70,right:70});
keyLight.shadow.bias = -0.0005; scene.add(keyLight);
const rimLight = new THREE.DirectionalLight(0x6030a0, 0.6); rimLight.position.set(50,20,-40); scene.add(rimLight);

const moonMat  = new THREE.MeshStandardMaterial({color:0xdde8ff,emissive:0xaabbdd,emissiveIntensity:1.5,roughness:0.9});
const moonMesh = new THREE.Mesh(new THREE.SphereGeometry(8,16,16), moonMat);
moonMesh.position.set(-130,160,-200); scene.add(moonMesh);
const moonGlow = new THREE.PointLight(0x8899cc, 80, 300); moonGlow.position.copy(moonMesh.position); scene.add(moonGlow);

const sunMat  = new THREE.MeshStandardMaterial({color:0xfffbe0,emissive:0xffee55,emissiveIntensity:3,roughness:1});
const sunMesh = new THREE.Mesh(new THREE.SphereGeometry(12,16,16), sunMat);
sunMesh.visible = false; scene.add(sunMesh);
const sunGlow = new THREE.PointLight(0xffeebb, 0, 400); scene.add(sunGlow);

const fireflyClusterA = new THREE.PointLight(0x99ffaa,6,20); scene.add(fireflyClusterA);
const fireflyClusterB = new THREE.PointLight(0xaaffcc,6,20); scene.add(fireflyClusterB);

// â”€â”€ Stars â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const STAR_COUNT=1800;
const starPos=new Float32Array(STAR_COUNT*3);
const starPhase=new Float32Array(STAR_COUNT); // twinkle phase offset per star
for(let i=0;i<STAR_COUNT;i++){
  const t=Math.random()*Math.PI*2,p=Math.acos(2*Math.random()-1),r=400+Math.random()*120;
  starPos[i*3]=r*Math.sin(p)*Math.cos(t); starPos[i*3+1]=Math.abs(r*Math.cos(p))+20; starPos[i*3+2]=r*Math.sin(p)*Math.sin(t);
  starPhase[i]=Math.random()*Math.PI*2;
}
const starGeo=new THREE.BufferGeometry();
starGeo.setAttribute('position',new THREE.BufferAttribute(starPos,3));
const starPoints=new THREE.Points(starGeo,new THREE.PointsMaterial({
  color:0xddeeff, size:0.55, sizeAttenuation:true, transparent:true, opacity:0
}));
scene.add(starPoints);

// â”€â”€ Shooting stars â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const shootingStars=[]; // pool of active streaks
let shootingStarTimer=0;
const SHOOT_INTERVAL_MIN=18, SHOOT_INTERVAL_MAX=60; // seconds between shots (at night)
let nextShootAt=SHOOT_INTERVAL_MIN+Math.random()*(SHOOT_INTERVAL_MAX-SHOOT_INTERVAL_MIN);

function spawnShootingStar(){
  // Random origin on upper hemisphere, high up
  const ang=Math.random()*Math.PI*2;
  const elevation=0.55+Math.random()*0.35; // 55-90% up the dome
  const R=350;
  const ox=Math.cos(ang)*R*Math.sqrt(1-elevation*elevation);
  const oy=elevation*R+40;
  const oz=Math.sin(ang)*R*Math.sqrt(1-elevation*elevation);
  // Direction: generally downward-ish across the sky
  const dirAngle=ang+Math.PI*(0.3+Math.random()*0.4);
  const dip=0.15+Math.random()*0.25;
  const speed=160+Math.random()*120;
  const vx=Math.cos(dirAngle)*speed;
  const vy=-dip*speed;
  const vz=Math.sin(dirAngle)*speed;
  // Trail: 3 elongated boxes of decreasing opacity
  const trailLen=3;
  const meshes=[];
  for(let t=0;t<trailLen;t++){
    const frac=t/trailLen;
    const geo=new THREE.BoxGeometry(0.8+t*0.5,0.8+t*0.4,12+t*10);
    const mat=new THREE.MeshBasicMaterial({color:0xeef4ff,transparent:true,opacity:(1-frac)*0.9});
    const m=new THREE.Mesh(geo,mat);
    scene.add(m);
    meshes.push(m);
  }
  shootingStars.push({ox,oy,oz,vx,vy,vz,t:0,life:0.55+Math.random()*0.3,meshes,dirAngle,dip});
}

function tickShootingStars(delta,elapsed,nightness){
  // Schedule next
  if(nightness>.4){
    shootingStarTimer+=delta;
    if(shootingStarTimer>=nextShootAt){
      spawnShootingStar();
      shootingStarTimer=0;
      nextShootAt=SHOOT_INTERVAL_MIN+Math.random()*(SHOOT_INTERVAL_MAX-SHOOT_INTERVAL_MIN);
    }
  }
  // Animate active
  for(let i=shootingStars.length-1;i>=0;i--){
    const s=shootingStars[i];
    s.t+=delta;
    const progress=s.t/s.life;
    const fade=progress<0.2?progress/0.2:1-(progress-0.2)/0.8;
    for(let ti=0;ti<s.meshes.length;ti++){
      const m=s.meshes[ti];
      const lag=ti*0.04;
      const lp=Math.max(0,s.t-lag);
      m.position.set(s.ox+s.vx*lp, s.oy+s.vy*lp, s.oz+s.vz*lp);
      // Orient along travel direction
      m.rotation.y=-s.dirAngle;
      m.rotation.x=Math.atan2(s.dip,1);
      m.material.opacity=Math.max(0,fade*(0.85-ti*0.25))*nightness;
      m.visible=nightness>.2;
    }
    if(s.t>=s.life){
      s.meshes.forEach(m=>{ scene.remove(m); m.geometry.dispose(); m.material.dispose(); });
      shootingStars.splice(i,1);
    }
  }
}

// Browser ctrl+scroll page-zoom blocked on desktop
window.addEventListener('wheel', e=>{ if(e.ctrlKey) e.preventDefault(); }, {passive:false});

function createBeach(){
  const dummy=new THREE.Object3D();
  const sandMat=new THREE.MeshStandardMaterial({color:'#c8b87a',roughness:.95});
  const wetMat =new THREE.MeshStandardMaterial({color:'#a09858',roughness:.9});
  const geo=new THREE.BoxGeometry(1,1,1);
  const wetMesh=new THREE.InstancedMesh(geo,wetMat,60);  wetMesh.receiveShadow=true;
  const dryMesh=new THREE.InstancedMesh(geo,sandMat,40); dryMesh.receiveShadow=true;
  let wi=0,di=0;
  for(let x=-40;x<40;x++) for(let z=-40;z<40;z++){
    const r=Math.sqrt(x*x+z*z);
    if(r<30||r>42) continue;
    const h=getGroundHeight(x,z);
    if(h<1||h>5) continue;
    const isWet=r>37.5;
    if(isWet&&wi<60){
      dummy.position.set(x,h+.05,z); dummy.scale.set(.9+Math.random()*.3,.12+Math.random()*.1,.9+Math.random()*.3);
      dummy.rotation.y=Math.random()*Math.PI; dummy.updateMatrix(); wetMesh.setMatrixAt(wi++,dummy.matrix);
    } else if(!isWet&&di<40){
      dummy.position.set(x,h+.04,z); dummy.scale.set(.8+Math.random()*.4,.1,.8+Math.random()*.4);
      dummy.rotation.y=Math.random()*Math.PI; dummy.updateMatrix(); dryMesh.setMatrixAt(di++,dummy.matrix);
    }
  }
  wetMesh.instanceMatrix.needsUpdate=true; dryMesh.instanceMatrix.needsUpdate=true;
  if(wi>0) scene.add(wetMesh); if(di>0) scene.add(dryMesh);

  // Pebbles / shells â€” small flattened dodecahedra in off-white and grey-tan
  const shellColors=['#e8dcc8','#d4c4a8','#c8b89a','#ddd0b8'];
  const shellGeos=[new THREE.DodecahedronGeometry(.22,0),new THREE.DodecahedronGeometry(.14,0)];
  const SHELLS=28;
  shellColors.forEach((col,ci)=>{
    const mat=new THREE.MeshStandardMaterial({color:col,roughness:.9});
    const sm=new THREE.InstancedMesh(shellGeos[ci%2],mat,7);
    sm.castShadow=false; sm.receiveShadow=true;
    for(let i=0;i<7;i++){
      const angle=0.1+Math.random()*1.1;
      const r=32+Math.random()*6, x=Math.cos(angle)*r, z=Math.sin(angle)*r;
      const h=getGroundHeight(x,z); if(h<1) continue;
      dummy.position.set(x+(Math.random()-.5)*.5, h+.06, z+(Math.random()-.5)*.5);
      dummy.scale.set(1+Math.random()*.4, .3+Math.random()*.25, 1+Math.random()*.4);
      dummy.rotation.set(Math.random()*.2,Math.random()*Math.PI,Math.random()*.2);
      dummy.updateMatrix(); sm.setMatrixAt(i,dummy.matrix);
    }
    sm.instanceMatrix.needsUpdate=true; scene.add(sm);
  });
}

const terrain = new Map();

function createWorld(){
  const grassMats=[
    new THREE.MeshStandardMaterial({color:'#3c583a'}),
    new THREE.MeshStandardMaterial({color:'#4a6946'}),
    new THREE.MeshStandardMaterial({color:'#2d422a'}),
  ];
  const sandMat=new THREE.MeshStandardMaterial({color:'#d2b48c'});
  const SIZE=40,WATER=1,buckets=[[],[],[],[]];
  for(let x=-SIZE;x<SIZE;x++) for(let z=-SIZE;z<SIZE;z++){
    const dist=Math.sqrt(x*x+z*z); if(dist>SIZE) continue;
    terrain.set(`${x},${z}`,Math.floor(2+(Math.sin(x/12)*Math.cos(z/12))*2.5+(SIZE-dist)*0.2));
  }
  let cx=-20,cz=10;
  for(let i=0;i<35;i++){
    for(let dx=-1;dx<=1;dx++) for(let dz=-1;dz<=1;dz++){
      const k=`${cx+dx},${cz+dz}`;
      if(terrain.has(k)&&terrain.get(k)>8) terrain.set(k,terrain.get(k)-1);
    }
    cx+=Math.round(Math.random()*2-1); cz+=Math.round(Math.random()*2-1);
  }
  for(const [key,h] of terrain){
    const [x,z]=key.split(',').map(Number);
    if(h>WATER) buckets[(x>25&&z>25&&h<4)?3:Math.floor(Math.random()*3)].push({x,y:h/2,z,h});
  }
  const dummy=new THREE.Object3D(),boxGeo=new THREE.BoxGeometry(1,1,1);
  [...grassMats,sandMat].forEach((mat,mi)=>{
    const pos=buckets[mi]; if(!pos.length) return;
    const mesh=new THREE.InstancedMesh(boxGeo,mat,pos.length);
    mesh.castShadow=mesh.receiveShadow=true;
    pos.forEach((p,i)=>{dummy.position.set(p.x,p.y,p.z);dummy.scale.set(1,p.h,1);dummy.updateMatrix();mesh.setMatrixAt(i,dummy.matrix);});
    scene.add(mesh);
  });
  createMountain(-50,-80,50,25); createVolcano(60,-90,45,20);
  createLayeredWater(SIZE,10,15);
}

function createMountain(px,pz,height,radius){
  const geo=new THREE.BoxGeometry(4,1,4),dummy=new THREE.Object3D(),stone=[],snow=[];
  for(let i=0;i<500;i++){
    const bx=(Math.random()-.5)*radius*2,bz=(Math.random()-.5)*radius*2;
    if(Math.sqrt(bx*bx+bz*bz)>radius) continue;
    const by=(radius-Math.sqrt(bx*bx+bz*bz))*(height/radius)+Math.random()*5;
    (by>height*.7?snow:stone).push({x:px+bx,y:by/2,z:pz+bz,h:by});
  }
  [stone,snow].forEach((arr,si)=>{
    if(!arr.length) return;
    const m=new THREE.InstancedMesh(geo,new THREE.MeshStandardMaterial({color:si===0?'#6b7280':'#ddeeff'}),arr.length);
    m.castShadow=true;
    arr.forEach((p,i)=>{dummy.position.set(p.x,p.y,p.z);dummy.scale.set(1,p.h,1);dummy.updateMatrix();m.setMatrixAt(i,dummy.matrix);});
    scene.add(m);
  });
}

function createVolcano(px,pz,height,radius){
  const geo=new THREE.BoxGeometry(4,1,4),dummy=new THREE.Object3D(),stone=[],caldera=[];
  for(let i=0;i<600;i++){
    const bx=(Math.random()-.5)*radius*2,bz=(Math.random()-.5)*radius*2;
    const dist=Math.sqrt(bx*bx+bz*bz); if(dist>radius) continue;
    const by=(radius-dist)*(height/radius)+Math.random()*4;
    (by>height*.82?caldera:stone).push({x:px+bx,y:by/2,z:pz+bz,h:by});
  }
  const basaltMat=new THREE.MeshStandardMaterial({color:'#3a3028',roughness:.98});
  const calderaMat=new THREE.MeshStandardMaterial({color:'#2a1a10',emissive:'#cc2200',emissiveIntensity:.3,roughness:.95});
  [stone,caldera].forEach((arr,si)=>{
    if(!arr.length) return;
    const m=new THREE.InstancedMesh(geo,si===0?basaltMat:calderaMat,arr.length);
    m.castShadow=true;
    arr.forEach((p,i)=>{dummy.position.set(p.x,p.y,p.z);dummy.scale.set(1,p.h,1);dummy.updateMatrix();m.setMatrixAt(i,dummy.matrix);});
    scene.add(m);
  });

  const calderaY=height*.88;

  // â”€â”€ Lava fill â€” scattered glowing voxel blocks inside the crater â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const lavaGeo=new THREE.BoxGeometry(2,1,2);
  const lavaBrightMat=new THREE.MeshStandardMaterial({color:'#ff3300',emissive:'#ff4400',emissiveIntensity:4,roughness:.9});
  const lavaDimMat=new THREE.MeshStandardMaterial({color:'#cc2200',emissive:'#aa1500',emissiveIntensity:2,roughness:.95});
  const LAVA_COUNT=28;
  const lavaInstA=new THREE.InstancedMesh(lavaGeo,lavaBrightMat,Math.ceil(LAVA_COUNT*.6));
  const lavaInstB=new THREE.InstancedMesh(lavaGeo,lavaDimMat,Math.floor(LAVA_COUNT*.4));
  let ia=0,ib=0;
  for(let i=0;i<200&&(ia<Math.ceil(LAVA_COUNT*.6)||ib<Math.floor(LAVA_COUNT*.4));i++){
    const angle=Math.random()*Math.PI*2, r=Math.random()*radius*.25;
    const lx=px+Math.cos(angle)*r, lz=pz+Math.sin(angle)*r;
    const lh=0.4+Math.random()*0.8;
    const ly=calderaY-lh/2+Math.random()*1.5;
    dummy.position.set(lx,ly,lz);
    dummy.scale.set(0.5+Math.random()*.5, lh, 0.5+Math.random()*.5);
    dummy.rotation.y=Math.random()*Math.PI; dummy.updateMatrix();
    if(Math.random()<.6&&ia<Math.ceil(LAVA_COUNT*.6)){ lavaInstA.setMatrixAt(ia++,dummy.matrix); }
    else if(ib<Math.floor(LAVA_COUNT*.4)){ lavaInstB.setMatrixAt(ib++,dummy.matrix); }
  }
  lavaInstA.instanceMatrix.needsUpdate=true; lavaInstB.instanceMatrix.needsUpdate=true;
  scene.add(lavaInstA,lavaInstB);

  // â”€â”€ Crater rim glow ring â€” emissive torus sitting at the caldera lip â”€â”€â”€â”€â”€â”€
  const rimGeo=new THREE.TorusGeometry(radius*.18,radius*.04,8,24);
  const rimMat=new THREE.MeshStandardMaterial({color:'#cc2200',emissive:'#ff2200',emissiveIntensity:3,roughness:.9});
  const rim=new THREE.Mesh(rimGeo,rimMat);
  rim.rotation.x=Math.PI/2; rim.position.set(px,calderaY+.4,pz); scene.add(rim);

  // â”€â”€ Lights â€” positioned AT the crater rim so glow clearly emanates from top
  const lavaGlow=new THREE.PointLight(0xff3300,200,120);
  lavaGlow.position.set(px,calderaY+1,pz); scene.add(lavaGlow);
  const emberGlow=new THREE.PointLight(0xff6600,100,80);
  emberGlow.position.set(px,calderaY-1,pz); scene.add(emberGlow);
  // Wide diffuse underbelly light to paint the mountain slopes orange
  const slopGlow=new THREE.PointLight(0xff2200,60,100);
  slopGlow.position.set(px,calderaY-8,pz); scene.add(slopGlow);
  volcanoLights=[lavaGlow,emberGlow,slopGlow];
}

function createPagoda(position){
  const g=new THREE.Group();
  const plaster=new THREE.MeshStandardMaterial({color:'#e8e0d0',roughness:.85}); // off-white walls
  const timber=new THREE.MeshStandardMaterial({color:'#2c1a0e',roughness:.88});  // dark wood beams
  const roofTile=new THREE.MeshStandardMaterial({color:'#3a3a3a',roughness:.9}); // charcoal roof tiles
  const roofRidge=new THREE.MeshStandardMaterial({color:'#5a5048',roughness:.92});
  const goldMat=new THREE.MeshStandardMaterial({color:'#c8a030',emissive:'#a07010',emissiveIntensity:.5,roughness:.5});

  // â”€â”€ Stone foundation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const fnd1=new THREE.Mesh(new THREE.BoxGeometry(9,.5,7.5),new THREE.MeshStandardMaterial({color:'#8a8070',roughness:.97}));
  fnd1.position.y=.25;
  const fnd2=new THREE.Mesh(new THREE.BoxGeometry(8,.4,6.5),new THREE.MeshStandardMaterial({color:'#706860',roughness:.97}));
  fnd2.position.y=.7;
  g.add(fnd1,fnd2);

  // â”€â”€ Main hall body â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const body=new THREE.Mesh(new THREE.BoxGeometry(6.5,3.5,5),plaster); body.position.set(0,2.65,0); g.add(body);

  // Timber framing â€” corner posts and horizontal tie beams
  const postGeo=new THREE.BoxGeometry(.28,3.5,.28);
  [[-3.1,0,-2.35],[3.1,0,-2.35],[-3.1,0,2.35],[3.1,0,2.35]].forEach(([px,,pz])=>{
    const p=new THREE.Mesh(postGeo,timber); p.position.set(px,2.65,pz); g.add(p);
  });
  // Horizontal tie beams top and bottom
  [[6.8,.22,5.2],[6.8,.22,5.2]].forEach(()=>{}); // placeholder, do manually:
  const topRailF=new THREE.Mesh(new THREE.BoxGeometry(6.8,.28,.22),timber); topRailF.position.set(0,4.15,-2.35); g.add(topRailF);
  const topRailB=topRailF.clone(); topRailB.position.set(0,4.15,2.35); g.add(topRailB);
  const topRailL=new THREE.Mesh(new THREE.BoxGeometry(.22,.28,5.2),timber); topRailL.position.set(-3.1,4.15,0); g.add(topRailL);
  const topRailR=topRailL.clone(); topRailR.position.set(3.1,4.15,0); g.add(topRailR);
  const botRailF=new THREE.Mesh(new THREE.BoxGeometry(6.8,.22,.22),timber); botRailF.position.set(0,1.1,-2.35); g.add(botRailF);
  const botRailB=botRailF.clone(); botRailB.position.set(0,1.1,2.35); g.add(botRailB);

  // Front entrance â€” dark recess with door suggestion
  const door=new THREE.Mesh(new THREE.BoxGeometry(1.2,2.2,.1),timber); door.position.set(0,2.0,-2.42); g.add(door);
  const dFrame=new THREE.Mesh(new THREE.BoxGeometry(1.6,.18,.12),timber); dFrame.position.set(0,3.15,-2.42); g.add(dFrame);

  // â”€â”€ Engawa (veranda) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const verandaF=new THREE.Mesh(new THREE.BoxGeometry(7.8,.18,1.1),new THREE.MeshStandardMaterial({color:'#4a2e14',roughness:.88}));
  verandaF.position.set(0,.98,-3.1); g.add(verandaF);
  const verandaRail=new THREE.Mesh(new THREE.BoxGeometry(7.8,.5,.08),timber); verandaRail.position.set(0,1.45,-3.7); g.add(verandaRail);

  // â”€â”€ Main irimoya roof â€” hip section â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Two long hip slopes (front & back)
  const hipF=new THREE.Mesh(new THREE.BoxGeometry(8.5,.12,3.2),roofTile); hipF.position.set(0,5.1,-1.4); hipF.rotation.x=-.45; g.add(hipF);
  const hipB=new THREE.Mesh(new THREE.BoxGeometry(8.5,.12,3.2),roofTile); hipB.position.set(0,5.1,1.4); hipB.rotation.x=.45; g.add(hipB);
  // Two gable end slopes
  const hipE1=new THREE.Mesh(new THREE.BoxGeometry(3.0,.12,4.2),roofTile); hipE1.position.set(-3.3,4.8,0); hipE1.rotation.z=.42; g.add(hipE1);
  const hipE2=hipE1.clone(); hipE2.position.set(3.3,4.8,0); hipE2.rotation.z=-.42; g.add(hipE2);
  // Ridge beam
  const ridge=new THREE.Mesh(new THREE.BoxGeometry(5.8,.35,.38),roofRidge); ridge.position.set(0,6.5,0); g.add(ridge);
  // Ridge end caps (shachi â€” decorative end tiles)
  [-2.8,2.8].forEach(rx=>{
    const sc=new THREE.Mesh(new THREE.BoxGeometry(.38,.55,.38),goldMat); sc.position.set(rx,6.78,0); g.add(sc);
  });
  // Eave trim strips
  [-2.55,2.55].forEach(z=>{
    const e=new THREE.Mesh(new THREE.BoxGeometry(8.8,.1,.22),roofRidge); e.position.set(0,4.32,z); g.add(e);
  });
  // Corner eave tips (upturned slightly)
  [[-4.1,-2.55],[-4.1,2.55],[4.1,-2.55],[4.1,2.55]].forEach(([rx,rz])=>{
    const tip=new THREE.Mesh(new THREE.BoxGeometry(.5,.18,.5),roofRidge);
    tip.position.set(rx,4.45,rz); tip.rotation.z=(rx<0?.12:-.12); tip.rotation.x=(rz<0?-.12:.12); g.add(tip);
  });

  // â”€â”€ Finial â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const finial=new THREE.Mesh(new THREE.CylinderGeometry(0,.25,.8,8),goldMat); finial.position.set(0,6.95,0); g.add(finial);
  const finialSph=new THREE.Mesh(new THREE.SphereGeometry(.14,8,8),goldMat); finialSph.position.set(0,7.4,0); g.add(finialSph);

  // â”€â”€ Subtle interior glow (emissive materials handle this)
  g.position.copy(position);
  g.traverse(c=>{if(c.isMesh){c.castShadow=c.receiveShadow=true;}}); scene.add(g);
}

function createToriiGate(position, rotY=0){
  const g=new THREE.Group(),mat=new THREE.MeshStandardMaterial({color:'#cc2200',roughness:.7}),dark=new THREE.MeshStandardMaterial({color:'#881500',roughness:.7});
  const postGeo=new THREE.CylinderGeometry(.28,.35,8,8);
  // Compute world-space foot positions for each post (Â±2.2 along local X after rotY)
  const cx=position.x, cz=position.z;
  const postGroundY = [-2.2, 2.2].map(lx=>{
    const wx = cx + lx * Math.cos(rotY);
    const wz = cz - lx * Math.sin(rotY);
    // Sample a small footprint and take the max so post is never floating
    return Math.max(
      getGroundHeight(wx, wz),
      getGroundHeight(wx+1, wz),
      getGroundHeight(wx-1, wz),
      getGroundHeight(wx, wz+1),
      getGroundHeight(wx, wz-1)
    );
  });
  // Gate group Y = highest of the two feet so neither post floats
  const gY = Math.max(postGroundY[0], postGroundY[1]);
  [-2.2,2.2].forEach((lx,i)=>{
    const post=new THREE.Mesh(postGeo,mat); post.position.set(lx,4,0); post.castShadow=true; g.add(post);
    // Sink each foot individually to fill any gap between post base and sloped terrain
    const footSink = gY - postGroundY[i]; // how much lower this post's terrain is
    const foot=new THREE.Mesh(new THREE.CylinderGeometry(.5,.5,.5+footSink,8),dark);
    foot.position.set(lx, .25 - footSink/2, 0); g.add(foot);
  });
  const kasagi=new THREE.Mesh(new THREE.BoxGeometry(7.2,.55,.7),dark); kasagi.position.set(0,8.3,0); kasagi.castShadow=true; g.add(kasagi);
  const shimagi=new THREE.Mesh(new THREE.BoxGeometry(5.8,.4,.55),mat); shimagi.position.set(0,7.65,0); g.add(shimagi);
  const nuki=new THREE.Mesh(new THREE.BoxGeometry(5.2,.35,.4),mat); nuki.position.set(0,5.5,0); g.add(nuki);
  [-1,1].forEach(s=>{
    const w=new THREE.Mesh(new THREE.BoxGeometry(.7,.3,.7),dark); w.position.set(s*3.25,8.45,0); w.rotation.z=s*.18; g.add(w);
  });
  g.rotation.y=rotY; g.position.set(cx, gY, cz);
  g.traverse(c=>{if(c.isMesh){c.castShadow=c.receiveShadow=true;}}); scene.add(g);
}

function createStoneShrine(position){
  const g=new THREE.Group();
  const stone=new THREE.MeshStandardMaterial({color:'#7a7570',roughness:.95});
  const darkStone=new THREE.MeshStandardMaterial({color:'#524e4a',roughness:.98});
  const wood=new THREE.MeshStandardMaterial({color:'#5a3820',roughness:.85});
  const redwood=new THREE.MeshStandardMaterial({color:'#9b2212',roughness:.8});
  const gold=new THREE.MeshStandardMaterial({color:'#c8a84b',emissive:'#8b6914',emissiveIntensity:.4,roughness:.6});
  const glowMat=new THREE.MeshStandardMaterial({color:0xfff0c0,emissive:0xffcc44,emissiveIntensity:4,roughness:1});

  // â”€â”€ Stone plinth steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const step1=new THREE.Mesh(new THREE.BoxGeometry(5.5,.35,4.5),stone); step1.position.set(0,.17,0);
  const step2=new THREE.Mesh(new THREE.BoxGeometry(4.8,.35,3.8),darkStone); step2.position.set(0,.52,0);
  const platform=new THREE.Mesh(new THREE.BoxGeometry(4.2,.28,3.2),stone); platform.position.set(0,.8,0);
  g.add(step1,step2,platform);

  // â”€â”€ Wooden floor deck â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const floor=new THREE.Mesh(new THREE.BoxGeometry(3.8,.15,2.8),wood); floor.position.set(0,.99,0); g.add(floor);

  // â”€â”€ Four posts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const postGeo=new THREE.CylinderGeometry(.14,.17,2.4,7);
  [[-1.5,0,-1.0],[1.5,0,-1.0],[-1.5,0,1.0],[1.5,0,1.0]].forEach(([px,,pz])=>{
    const post=new THREE.Mesh(postGeo,redwood); post.position.set(px,2.2,pz); g.add(post);
  });

  // â”€â”€ Tie beams â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const beam=new THREE.Mesh(new THREE.BoxGeometry(3.4,.2,.18),wood); beam.position.set(0,3.3,-1.0); g.add(beam);
  const beam2=beam.clone(); beam2.position.set(0,3.3,1.0); g.add(beam2);
  const sideBeam=new THREE.Mesh(new THREE.BoxGeometry(.18,.2,2.2),wood); sideBeam.position.set(-1.5,3.3,0); g.add(sideBeam);
  const sideBeam2=sideBeam.clone(); sideBeam2.position.set(1.5,3.3,0); g.add(sideBeam2);

  // â”€â”€ Gabled roof â€” ridge + two slopes + overhanging eaves â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Main slopes (hip roof via two angled slabs)
  const slopeGeo=new THREE.BoxGeometry(4.8,.12,1.7);
  const slopeF=new THREE.Mesh(slopeGeo,darkStone); slopeF.position.set(0,3.75,-.7); slopeF.rotation.x=-.32; g.add(slopeF);
  const slopeB=new THREE.Mesh(slopeGeo,darkStone); slopeB.position.set(0,3.75,.7); slopeB.rotation.x=.32; g.add(slopeB);
  // Ridge beam
  const ridge=new THREE.Mesh(new THREE.BoxGeometry(4.9,.28,.28),darkStone); ridge.position.set(0,4.2,0); g.add(ridge);
  // End caps (gable triangles)
  const gableGeo=new THREE.CylinderGeometry(0,.9,.9,4,1);
  const gableL=new THREE.Mesh(gableGeo,stone); gableL.position.set(-2.3,3.65,0); gableL.rotation.z=-Math.PI/2; gableL.rotation.y=Math.PI/4; g.add(gableL);
  const gableR=gableL.clone(); gableR.position.set(2.3,3.65,0); gableR.rotation.z=Math.PI/2; g.add(gableR);
  // Eave trim strips
  const eaveGeo=new THREE.BoxGeometry(5.2,.1,.18);
  [-1.4,1.4].forEach(z=>{ const e=new THREE.Mesh(eaveGeo,wood); e.position.set(0,3.42,z); g.add(e); });

  // â”€â”€ Offering box / altar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const altar=new THREE.Mesh(new THREE.BoxGeometry(1.2,.55,0.9),stone); altar.position.set(0,1.27,-.5); g.add(altar);
  const altarTop=new THREE.Mesh(new THREE.BoxGeometry(1.35,.1,1.0),darkStone); altarTop.position.set(0,1.58,-.5); g.add(altarTop);
  // Coin slot slit
  const slot=new THREE.Mesh(new THREE.BoxGeometry(.5,.04,.1),new THREE.MeshStandardMaterial({color:'#222',roughness:1})); slot.position.set(0,1.64,-.96); g.add(slot);

  // â”€â”€ Rope (shimenawa) â€” zigzag box chain across front â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const ropeMat=new THREE.MeshStandardMaterial({color:'#d4c070',roughness:.9});
  for(let i=0;i<7;i++){
    const seg=new THREE.Mesh(new THREE.BoxGeometry(.45,.1,.1),ropeMat);
    seg.position.set(-1.35+i*.45, 2.5+(i%2)*.12, -1.02);
    seg.rotation.z=(i%2===0?.1:-.1); g.add(seg);
  }

  // â”€â”€ Flanking stone lanterns â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  [-2.2,2.2].forEach(lx=>{
    const base=new THREE.Mesh(new THREE.CylinderGeometry(.22,.28,.28,6),stone); base.position.set(lx,.42,0);
    const shaft=new THREE.Mesh(new THREE.CylinderGeometry(.1,.14,.8,6),stone); shaft.position.set(lx,.98,0);
    const cap=new THREE.Mesh(new THREE.CylinderGeometry(.32,.16,.2,6),stone); cap.position.set(lx,1.48,0);
    const hood=new THREE.Mesh(new THREE.CylinderGeometry(0,.38,.5,6),darkStone); hood.position.set(lx,1.8,0);
    const flame=new THREE.Mesh(new THREE.SphereGeometry(.1,5,5),glowMat); flame.position.set(lx,1.55,0);
    g.add(base,shaft,cap,hood,flame);
  });

  // â”€â”€ Komainu (guardian stones) â€” simplified at base corners â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  [-2.0,2.0].forEach(lx=>{
    const body=new THREE.Mesh(new THREE.BoxGeometry(.4,.5,.35),stone); body.position.set(lx,.65,1.6);
    const head=new THREE.Mesh(new THREE.BoxGeometry(.32,.3,.28),stone); head.position.set(lx,1.05,1.6);
    const mane=new THREE.Mesh(new THREE.SphereGeometry(.2,5,4),darkStone); mane.position.set(lx,1.12,1.5); mane.scale.set(1,.7,1);
    g.add(body,head,mane);
  });

  // â”€â”€ Central glow orb â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const orb=new THREE.Mesh(new THREE.SphereGeometry(.12,6,6),glowMat); orb.position.set(0,1.85,-.5); g.add(orb);
  // Single combined PointLight for whole shrine (replaces 3 â€” cheaper)
  const shrineLight=new THREE.PointLight(0xffdd88,28,14); shrineLight.position.set(0,2,0); g.add(shrineLight);

  g.position.copy(position);
  g.traverse(c=>{if(c.isMesh){c.castShadow=c.receiveShadow=true;}}); scene.add(g);
}

function createLampPost(position){
  const g=new THREE.Group();
  const ironMat=new THREE.MeshStandardMaterial({color:'#2a2a2a',roughness:.7,metalness:.5});
  const stoneMat=new THREE.MeshStandardMaterial({color:'#7a7570',roughness:.95});
  const glowMat=new THREE.MeshStandardMaterial({color:0xfff8d0,emissive:0xffdd66,emissiveIntensity:8,transparent:true,opacity:.92});

  // Stone base
  const base=new THREE.Mesh(new THREE.CylinderGeometry(.32,.38,.3,8),stoneMat); base.position.y=.15;
  // Iron shaft
  const shaft=new THREE.Mesh(new THREE.CylinderGeometry(.06,.1,4.2,8),ironMat); shaft.position.y=2.35;
  // Collar ring
  const collar=new THREE.Mesh(new THREE.CylinderGeometry(.18,.18,.12,8),ironMat); collar.position.y=4.42;
  // Lantern box â€” semi-transparent with emissive tint so walls bleed light
  const lBox=new THREE.Mesh(new THREE.BoxGeometry(.72,.72,.72),
    new THREE.MeshStandardMaterial({color:'#1a1a1a',emissive:'#ffcc44',emissiveIntensity:.6,roughness:.8,transparent:true,opacity:.45}));
  lBox.position.y=4.9;
  // Inner glow sphere
  const glow=new THREE.Mesh(new THREE.SphereGeometry(.22,6,6),glowMat); glow.position.y=4.9;
  // Soft halo â€” large transparent sphere to simulate light bleed
  const haloMat=new THREE.MeshStandardMaterial({color:0xffee88,emissive:0xffcc44,emissiveIntensity:1.2,transparent:true,opacity:.08,depthWrite:false,side:THREE.BackSide});
  const halo=new THREE.Mesh(new THREE.SphereGeometry(1.1,8,8),haloMat); halo.position.y=4.9;
  // Pagoda cap roof
  const cap=new THREE.Mesh(new THREE.CylinderGeometry(0,.7,.5,4),ironMat); cap.position.y=5.35; cap.rotation.y=Math.PI/4;
  // Point light
  const light=new THREE.PointLight(0xffcc55,55,20); light.position.y=4.9;

  g.add(base,shaft,collar,lBox,glow,halo,cap,light);
  g.position.copy(position);
  g.traverse(c=>{if(c.isMesh){c.castShadow=c.receiveShadow=true;}}); scene.add(g);
}

function createLayeredWater(startR,layers,step){
  const c0=new THREE.Color('#7ec8e8'),c1=new THREE.Color('#3a7fcc'),c2=new THREE.Color('#0d2a5e');
  const e0=new THREE.Color('#1a4a88'),e1=new THREE.Color('#0a1e44');
  for(let i=0;i<layers;i++){
    const t=i/(layers-1);
    const col=i===0?c0.clone():new THREE.Color().lerpColors(c1,c2,t);
    const emi=new THREE.Color().lerpColors(e0,e1,t);
    const ring=new THREE.Mesh(new THREE.RingGeometry(startR+i*step,startR+(i+1)*step,64),
      new THREE.MeshStandardMaterial({color:col,emissive:emi,emissiveIntensity:0.55,transparent:true,opacity:.6+t*.3,roughness:.12,metalness:.25}));
    ring.rotation.x=-Math.PI/2; ring.position.y=1.5; scene.add(ring);
  }
}

function createBambooGrove(cx,cz,count=28){
  const culm=new THREE.CylinderGeometry(.12,.15,7,6),node=new THREE.CylinderGeometry(.18,.18,.2,6);
  const mat=new THREE.MeshStandardMaterial({color:'#5a8a30',roughness:.8}),nMat=new THREE.MeshStandardMaterial({color:'#3d6620',roughness:.9});
  const dummy=new THREE.Object3D(),culmMesh=new THREE.InstancedMesh(culm,mat,count),nodeMesh=new THREE.InstancedMesh(node,nMat,count*2);
  culmMesh.castShadow=nodeMesh.castShadow=true;
  for(let i=0;i<count;i++){
    const angle=Math.random()*Math.PI*2,r=Math.random()*4.5,x=cx+Math.cos(angle)*r,z=cz+Math.sin(angle)*r;
    const y=getGroundHeight(x,z),h=5+Math.random()*3,lean=(Math.random()-.5)*.1;
    dummy.position.set(x,y+h/2,z); dummy.scale.set(1,h/7,1); dummy.rotation.set(lean,Math.random()*Math.PI*2,lean); dummy.updateMatrix();
    culmMesh.setMatrixAt(i,dummy.matrix);
    [.35,.65].forEach((frac,ni)=>{dummy.position.set(x,y+h*frac,z);dummy.scale.setScalar(1);dummy.rotation.set(0,0,0);dummy.updateMatrix();nodeMesh.setMatrixAt(i*2+ni,dummy.matrix);});
  }
  culmMesh.instanceMatrix.needsUpdate=nodeMesh.instanceMatrix.needsUpdate=true;
  scene.add(culmMesh,nodeMesh);
}

function createScatteredRocks(){
  const dummy=new THREE.Object3D(),rockMat=new THREE.MeshStandardMaterial({color:'#7a7a72',roughness:.95});
  const gS=new THREE.DodecahedronGeometry(.35,0),gM=new THREE.DodecahedronGeometry(.75,0);
  const SMALL=40,MED=18;
  const smM=new THREE.InstancedMesh(gS,rockMat,SMALL),mdM=new THREE.InstancedMesh(gM,rockMat,MED);
  smM.castShadow=smM.receiveShadow=mdM.castShadow=mdM.receiveShadow=true;
  let si=0,mi=0;
  for(let attempt=0;attempt<600&&(si<SMALL||mi<MED);attempt++){
    const angle=Math.random()*Math.PI*2,r=4+Math.random()*32,x=Math.cos(angle)*r,z=Math.sin(angle)*r,y=getGroundHeight(x,z);
    if(y<2) continue;
    const isMed=mi<MED&&Math.random()<.3;
    const mesh=isMed?mdM:smM,idx=isMed?mi++:si++;
    if(idx>=(isMed?MED:SMALL)) continue;
    dummy.position.set(x,y-.1,z); dummy.scale.set(.8+Math.random()*.4,.6+Math.random()*.5,.8+Math.random()*.4);
    dummy.rotation.set(Math.random()*.4,Math.random()*Math.PI,Math.random()*.4); dummy.updateMatrix();
    mesh.setMatrixAt(idx,dummy.matrix);
  }
  smM.instanceMatrix.needsUpdate=mdM.instanceMatrix.needsUpdate=true; scene.add(smM,mdM);
}

function createGrassTufts(){
  const dummy=new THREE.Object3D(),tuftGeo=new THREE.BoxGeometry(.08,1,.08);
  const tuftMat=new THREE.MeshStandardMaterial({color:'#5c8a2a',roughness:1});
  const COUNT=180,mesh=new THREE.InstancedMesh(tuftGeo,tuftMat,COUNT);
  mesh.castShadow=false;
  for(let i=0;i<COUNT;i++){
    const angle=Math.random()*Math.PI*2,r=2+Math.random()*36,x=Math.cos(angle)*r,z=Math.sin(angle)*r,y=getGroundHeight(x,z);
    if(y<2){i--;continue;}
    const h=.5+Math.random()*.9;
    dummy.position.set(x+(Math.random()-.5)*.4,y+h/2,z+(Math.random()-.5)*.4);
    dummy.scale.set(.8+Math.random()*.5,h,.8+Math.random()*.5); dummy.rotation.set((Math.random()-.5)*.3,Math.random()*Math.PI,(Math.random()-.5)*.3);
    dummy.updateMatrix(); mesh.setMatrixAt(i,dummy.matrix);
  }
  mesh.instanceMatrix.needsUpdate=true; scene.add(mesh);
}

function createPath(waypoints){
  // Catmull-Rom spline through waypoints
  const STRIDE=1.05;
  const sp=[];
  const n=waypoints.length;
  for(let s=0;s<n-1;s++){
    const p0=waypoints[Math.max(0,s-1)],p1=waypoints[s],p2=waypoints[s+1],p3=waypoints[Math.min(n-1,s+2)];
    for(let j=0;j<60;j++){
      const t=j/60,t2=t*t,t3=t2*t;
      sp.push([
        .5*((2*p1[0])+(-p0[0]+p2[0])*t+(2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t2+(-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t3),
        .5*((2*p1[1])+(-p0[1]+p2[1])*t+(2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t2+(-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t3)
      ]);
    }
  }
  sp.push(waypoints[n-1]);
  const stones=[],dirties=[];
  let acc=0,prev=sp[0];
  for(let i=1;i<sp.length;i++){
    const cur=sp[i],dx=cur[0]-prev[0],dz=cur[1]-prev[1],len=Math.sqrt(dx*dx+dz*dz);
    acc+=len;
    if(acc>=STRIDE){
      acc-=STRIDE;
      const perp=Math.atan2(dx,dz)+Math.PI/2,w=(Math.random()-.5)*.15;
      const wx=cur[0]+Math.cos(perp)*w,wz=cur[1]+Math.sin(perp)*w;
      const y=getGroundHeight(wx,wz),rot=Math.atan2(dx,dz)+(Math.random()-.5)*.2,sc=.78+Math.random()*.25;
      if(y<=1) dirties.push({x:wx,y,z:wz,rot,sc});
      else     stones .push({x:wx,y,z:wz,rot,sc});
    }
    prev=cur;
  }
  const dummy=new THREE.Object3D();
  [{arr:stones,geo:new THREE.CylinderGeometry(.42,.5,.14,7),mat:new THREE.MeshStandardMaterial({color:'#9a9080',roughness:.97}),yOff:.07},
   {arr:dirties,geo:new THREE.BoxGeometry(.55,.09,.55),mat:new THREE.MeshStandardMaterial({color:'#7a5c38',roughness:.99}),yOff:.05}
  ].forEach(({arr,geo,mat,yOff})=>{
    if(!arr.length)return;
    const mesh=new THREE.InstancedMesh(geo,mat,arr.length);
    mesh.receiveShadow=true;
    arr.forEach((s,i)=>{dummy.position.set(s.x,s.y+yOff,s.z);dummy.rotation.set(0,s.rot,0);dummy.scale.set(s.sc,1,s.sc);dummy.updateMatrix();mesh.setMatrixAt(i,dummy.matrix);});
    mesh.instanceMatrix.needsUpdate=true;scene.add(mesh);
  });
}

function createOvalPath(){
  // Main loop follows the actual h=6-7 terrain contour â€” mid-slope walking band.
  // Generated by sampling the heightmap radially. Feels natural because it IS the terrain.
  createPath([
    [23.0, 0.0],
    [19.7, 7.2],
    [13.0,10.9],
    [ 7.0,12.1],
    [ 2.1,11.8],
    [-1.6, 8.9],
    [-4.0, 6.9],
    [-6.1, 5.1],
    [-7.5, 2.7],
    [-8.0, 0.0],
    [-7.5,-2.7],
    [-6.1,-5.1],
    [-4.0,-6.9],
    [-1.6,-8.9],
    [ 2.1,-11.8],
    [ 7.0,-12.1],
    [13.0,-10.9],
    [19.7,-7.2],
    [23.0, 0.0],   // close
  ]);

  // Short spurs to outlying landmarks â€” branch off the circuit, walk out, done
  createPath([[2.1,11.8],[0,14],[0,16]]);           // â†’ pagoda
  createPath([[-4.0,6.9],[-10,10],[-16,13],[-18,14]]); // â†’ north shrine
  createPath([[-4.0,-6.9],[-6,-10],[-8,-14]]);      // â†’ well
  createPath([[19.7,7.2],[22,14],[24,20],[26,24]]); // â†’ beach torii
}



// â”€â”€ Ocean lily pads â€” scattered in the water ring around the island â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createOceanLilyPads(){
  const dummy = new THREE.Object3D();
  const COUNT = 22;
  const padMat  = new THREE.MeshStandardMaterial({color:'#2d6a2d', roughness:.85, side:THREE.DoubleSide});
  const slitMat = new THREE.MeshStandardMaterial({color:'#1a3d2e', transparent:true, opacity:.8});
  const petalMat= new THREE.MeshStandardMaterial({color:'#f9d0e0', emissive:'#f472b6', emissiveIntensity:.5, roughness:.6});
  const padGeo  = new THREE.CircleGeometry(1, 14);
  const padMesh = new THREE.InstancedMesh(padGeo, padMat, COUNT);
  padMesh.receiveShadow = false;

  for(let i=0; i<COUNT; i++){
    const angle  = (i/COUNT)*Math.PI*2 + Math.random()*.4;
    // Scatter between radius 42 and 72 â€” inside the layered water
    const r      = 43 + Math.random()*28;
    const x      = Math.cos(angle)*r, z = Math.sin(angle)*r;
    const scale  = 0.7 + Math.random()*0.6;
    dummy.position.set(x, 1.72, z);
    dummy.scale.setScalar(scale);
    dummy.rotation.set(-Math.PI/2, 0, Math.random()*Math.PI*2);
    dummy.updateMatrix();
    padMesh.setMatrixAt(i, dummy.matrix);

    // Notch slit â€” thin dark strip across the pad (simulates the leaf split)
    const slit = new THREE.Mesh(new THREE.BoxGeometry(.08, .01, scale*1.9), slitMat);
    slit.position.set(x, 1.74, z);
    slit.rotation.y = Math.random()*Math.PI;
    scene.add(slit);

    // Sparse flower on every ~4th pad
    if(i%4===0){
      const fg=new THREE.Group();
      for(let p=0;p<5;p++){
        const petal=new THREE.Mesh(new THREE.BoxGeometry(.13,.04,.32),petalMat);
        petal.rotation.y=(p/5)*Math.PI*2;
        petal.position.set(Math.cos((p/5)*Math.PI*2)*.14, 0, Math.sin((p/5)*Math.PI*2)*.14);
        fg.add(petal);
      }
      fg.add(new THREE.Mesh(
        new THREE.SphereGeometry(.08,5,5),
        new THREE.MeshStandardMaterial({color:0xfff176,emissive:0xffd600,emissiveIntensity:1.5})
      ));
      fg.position.set(x, 1.79, z);
      scene.add(fg);
    }
  }
  padMesh.instanceMatrix.needsUpdate=true;
  scene.add(padMesh);
}


// â”€â”€ Koi Fish â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const koiFish=[];
function createKoiFish(){
  const koiDefs=[
    {base:0xf47a4a, spot:0xffffff, name:'orange'},  // orange with white
    {base:0xfafafa, spot:0xf47a4a, name:'white'},   // white with orange
    {base:0xf0c040, spot:0xcc3030, name:'yellow'},  // yellow with red
    {base:0xe84040, spot:0xfafafa, name:'red'},     // red with white
    {base:0xf47a4a, spot:0xcc2020, name:'kohaku'},  // classic kohaku
  ];
  for(let i=0;i<5;i++){
    const def=koiDefs[i];
    const koi=new THREE.Group();
    const baseMat=new THREE.MeshStandardMaterial({color:def.base,roughness:.35,metalness:.15});
    const spotMat=new THREE.MeshStandardMaterial({color:def.spot,roughness:.35,metalness:.1});
    const darkMat=new THREE.MeshStandardMaterial({color:0x1a0a00,roughness:.5});
    const finMat=new THREE.MeshStandardMaterial({color:def.base,roughness:.5,transparent:true,opacity:.75});

    // Body â€” elongated ellipsoid built from scaled sphere
    const body=new THREE.Mesh(new THREE.SphereGeometry(.5,8,6),baseMat);
    body.scale.set(.48,.18,.28); koi.add(body);

    // Colour patch on back â€” irregular blob
    const patch=new THREE.Mesh(new THREE.SphereGeometry(.32,6,5),spotMat);
    patch.scale.set(.55,.12,.3); patch.position.set(.05,.065,-.04); koi.add(patch);

    // Head â€” slightly bulbous
    const head=new THREE.Mesh(new THREE.SphereGeometry(.22,7,5),baseMat);
    head.scale.set(.8,.75,.85); head.position.set(0,0,.26); koi.add(head);

    // Eyes â€” tiny dark dots on head sides
    [-1,1].forEach(side=>{
      const eye=new THREE.Mesh(new THREE.SphereGeometry(.04,5,4),darkMat);
      eye.position.set(side*.14,.04,.3); koi.add(eye);
    });

    // Mouth â€” tiny flat box at snout
    const mouth=new THREE.Mesh(new THREE.BoxGeometry(.08,.03,.04),darkMat);
    mouth.position.set(0,-.04,.37); koi.add(mouth);

    // Dorsal fin â€” thin flat triangle on top
    const dorsalGeo=new THREE.BufferGeometry();
    dorsalGeo.setAttribute('position',new THREE.BufferAttribute(new Float32Array([
       0, .0,  .08,   // base front
       0, .0, -.08,   // base back
       0, .14,  0,    // tip top
    ]),3));
    dorsalGeo.setIndex([0,2,1]);
    dorsalGeo.computeVertexNormals();
    const dorsal=new THREE.Mesh(dorsalGeo,finMat);
    dorsal.position.set(0,.18,.0); dorsal.scale.set(1.2,1,1.4); koi.add(dorsal);

    // Pectoral fins â€” two small side fins
    [-1,1].forEach(side=>{
      const pec=new THREE.Mesh(new THREE.SphereGeometry(.1,5,3),finMat);
      pec.scale.set(.25,.08,.45); pec.position.set(side*.2,-.04,.15);
      pec.rotation.z=side*.4; koi.add(pec);
    });

    // Caudal (tail) â€” two lobes, fan shape
    const tailPivot=new THREE.Group(); tailPivot.position.set(0,0,-.28);
    [-.12,.12].forEach(yOff=>{
      const lobe=new THREE.Mesh(new THREE.SphereGeometry(.18,5,4),finMat);
      lobe.scale.set(.22,.5,.65); lobe.position.set(0,yOff,-.14);
      lobe.rotation.x=yOff>0?.25:-.25; tailPivot.add(lobe);
    });
    koi.add(tailPivot);

    // Mid-body segment for S-curve flex
    const midPivot=new THREE.Group(); midPivot.position.set(0,0,-.08);
    const mid=new THREE.Mesh(new THREE.SphereGeometry(.32,7,5),baseMat);
    mid.scale.set(.42,.16,.22); midPivot.add(mid);
    koi.add(midPivot);

    const orbitR=50+Math.random()*16, offset=Math.random()*Math.PI*2;
    koi.position.set(Math.cos(offset)*orbitR, 0.55, Math.sin(offset)*orbitR);
    scene.add(koi);

    koiFish.push({
      group:koi, tailPivot, midPivot,
      angle: offset,
      orbitR,
      wobble: Math.random()*Math.PI*2,
      spd: 0,
      targetSpd: 0.04+Math.random()*0.05,
      spdTimer: 0,
      nextSpdChange: 4+Math.random()*6,
      paused: false,
      pauseTimer: 0,
      pauseDur: 0,
      // S-curve swerve state
      swervePhase: Math.random()*Math.PI*2,
      swerveFreq: 0.12+Math.random()*0.1,   // how often swerve direction shifts
      swerveAmp: 4+Math.random()*5,         // units of lateral swerve
    });
  }
}

// â”€â”€ Birds (Seagulls) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const birds=[];
const gullBodyMat =new THREE.MeshStandardMaterial({color:'#e8e8e0',roughness:.7});
const gullWingMat =new THREE.MeshStandardMaterial({color:'#d0d0c8',roughness:.7});
const gullTipMat  =new THREE.MeshStandardMaterial({color:'#555560',roughness:.7}); // dark wingtips
const gullBeakMat =new THREE.MeshStandardMaterial({color:'#d4a020',roughness:.5});

function makeBird(){
  const g=new THREE.Group();
  // Body â€” white, slightly plump
  const body=new THREE.Mesh(new THREE.BoxGeometry(.38,.16,.6),gullBodyMat);
  g.add(body);
  // Head â€” rounder than body
  const head=new THREE.Mesh(new THREE.BoxGeometry(.24,.22,.26),gullBodyMat);
  head.position.set(0,.08,.32); g.add(head);
  // Beak â€” small yellow wedge
  const beak=new THREE.Mesh(new THREE.BoxGeometry(.07,.06,.18),gullBeakMat);
  beak.position.set(0,.04,.46); g.add(beak);
  // Left wing pivot â€” seagulls have longer, narrower wings
  const lw=new THREE.Group();
  const lwInner=new THREE.Mesh(new THREE.BoxGeometry(.7,.06,.28),gullWingMat);
  lwInner.position.x=-.38; lw.add(lwInner);
  const lwTip=new THREE.Mesh(new THREE.BoxGeometry(.55,.05,.18),gullTipMat);
  lwTip.position.set(-1.0,0,.0); lw.add(lwTip);
  g.add(lw);
  // Right wing pivot
  const rw=new THREE.Group();
  const rwInner=new THREE.Mesh(new THREE.BoxGeometry(.7,.06,.28),gullWingMat);
  rwInner.position.x=.38; rw.add(rwInner);
  const rwTip=new THREE.Mesh(new THREE.BoxGeometry(.55,.05,.18),gullTipMat);
  rwTip.position.set(1.0,0,.0); rw.add(rwTip);
  g.add(rw);
  // Tail â€” short fan
  const tail=new THREE.Mesh(new THREE.BoxGeometry(.22,.06,.18),gullBodyMat);
  tail.position.set(0,-.03,-.34); g.add(tail);
  return {g, lw, rw};
}

const BIRD_MAX=4;
let birdSpawnTimer=0;
const BIRD_SPAWN_INTERVAL=18; // seconds

function spawnBird(dxOff=0, dyOff=0, dzOff=0){
  const {g,lw,rw}=makeBird();

  // Spawn just inside the fog boundary â€” birds emerge and vanish naturally
  // Camera is at (0,25,60). Visible zone roughly r=20 to r=90 from origin.
  // Spawn at r=90, fly to opposite r=90.
  const inAngle = Math.random()*Math.PI*2;
  const R = 90;
  const sx = Math.cos(inAngle)*R + dxOff;
  const sz = Math.sin(inAngle)*R + dzOff;
  const sy = 18 + Math.random()*10 + dyOff;  // 18-28 units â€” just above island

  // Exit: truly opposite side (+PI), tiny spread so they don't beeline identically
  const outAngle = inAngle + Math.PI + (Math.random()-.5)*.3;
  const ex = Math.cos(outAngle)*R;
  const ez = Math.sin(outAngle)*R;
  const ey = 18 + Math.random()*10;

  // Face direction of travel from the start (constant â€” no heading drift)
  const travelYaw = Math.atan2(ex-sx, ez-sz);
  g.rotation.y = travelYaw;

  g.position.set(sx,sy,sz);
  scene.add(g);

  // Speed 18-26 units/sec â†’ crosses visible zone in ~7-10s
  const dist = Math.sqrt((ex-sx)**2+(ez-sz)**2);
  const spd = 18+Math.random()*8;
  const duration = dist/spd;

  birds.push({
    g, lw, rw,
    sx,sy,sz, ex,ey,ez,
    t:0, duration,
    wobble: Math.random()*Math.PI*2,
    flapFreq: 3.8+Math.random()*2,
    flapAmp:  .45+Math.random()*.2,
    gliding: false,
    glideTimer: 0,
    nextGlide: 2.5+Math.random()*5,   // seconds until first glide
    glideDur:  1.2+Math.random()*3,
    flapDur:   2+Math.random()*3.5,
    bank: 0,
  });
}

function spawnFlock(){
  const n = 2+Math.floor(Math.random()*2);
  for(let i=0;i<n;i++){
    // Formation offset: spread perpendicular to travel, same rough direction
    spawnBird((Math.random()-.5)*10,(Math.random()-.5)*6,(Math.random()-.5)*10);
  }
}

function tickBirds(delta, elapsed){
  birdSpawnTimer+=delta;
  if(birdSpawnTimer>=BIRD_SPAWN_INTERVAL && birds.length<BIRD_MAX){
    birdSpawnTimer=0;
    Math.random()<.35 ? spawnFlock() : spawnBird();
  }

  for(let i=birds.length-1;i>=0;i--){
    const b=birds[i];
    b.t = Math.min(b.t+delta/b.duration, 1);

    // â”€â”€ Pure linear interpolation â€” guaranteed straight line â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    b.g.position.x = b.sx+(b.ex-b.sx)*b.t;
    b.g.position.y = b.sy+(b.ey-b.sy)*b.t;
    b.g.position.z = b.sz+(b.ez-b.sz)*b.t;

    // â”€â”€ Glide / flap cycle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    b.glideTimer+=delta;
    if(!b.gliding && b.glideTimer>b.flapDur){
      b.gliding=true; b.glideTimer=0;
    } else if(b.gliding && b.glideTimer>b.glideDur){
      b.gliding=false; b.glideTimer=0;
      b.flapDur  = 2+Math.random()*3.5;
      b.glideDur = 1.2+Math.random()*3;
    }

    // â”€â”€ Wing animation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if(!b.gliding){
      // Asymmetric flap: snappy down, lazy up
      const raw = Math.sin(elapsed*b.flapFreq+b.wobble);
      const snap = raw>0 ? Math.pow(raw,.6) : -Math.pow(-raw,1.5);
      b.lw.rotation.z =  snap*b.flapAmp;
      b.rw.rotation.z = -snap*b.flapAmp;
    } else {
      // Glide: held-up dihedral, slow sway
      const target = .1+Math.sin(elapsed*.6+b.wobble)*.03;
      b.lw.rotation.z = THREE.MathUtils.lerp(b.lw.rotation.z, target,.07);
      b.rw.rotation.z = THREE.MathUtils.lerp(b.rw.rotation.z,-target,.07);
    }

    // Despawn once reached destination
    if(b.t>=1){
      scene.remove(b.g);
      birds.splice(i,1);
    }
  }
}

// â”€â”€ Water Ripples â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ripples=[];
let rippleTimer=0;
const rippleGeo=new THREE.TorusGeometry(1,.06,6,32);
const rippleMat=new THREE.MeshStandardMaterial({color:0x88bbff,transparent:true,opacity:.5,roughness:.1});

function tickRipples(delta){
  rippleTimer+=delta;
  if(rippleTimer>2.5){
    rippleTimer=0;
    // Spawn at random position in the water ring
    const angle=Math.random()*Math.PI*2,r=42+Math.random()*12;
    const mesh=new THREE.Mesh(rippleGeo,rippleMat.clone());
    mesh.rotation.x=-Math.PI/2; mesh.position.set(Math.cos(angle)*r,1.7,Math.sin(angle)*r); scene.add(mesh);
    ripples.push({mesh,life:0,maxLife:2.2});
  }
  for(let i=ripples.length-1;i>=0;i--){
    const r=ripples[i]; r.life+=delta;
    const t=r.life/r.maxLife;
    r.mesh.scale.setScalar(1+t*3.5);
    r.mesh.material.opacity=.5*(1-t*t);
    if(r.life>=r.maxLife){ scene.remove(r.mesh); r.mesh.material.dispose(); ripples.splice(i,1); }
  }
}

const getGroundHeight=(x,z)=>terrain.get(`${Math.round(x)},${Math.round(z)}`)||0;

// â”€â”€ Fireflies â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FIREFLY_COUNT=35,fireflies=[];
const fireflyInstanced=new THREE.InstancedMesh(new THREE.SphereGeometry(.12,4,4),new THREE.MeshStandardMaterial({emissive:0x99ffaa,emissiveIntensity:0,color:0x000000}),FIREFLY_COUNT);
fireflyInstanced.instanceMatrix.setUsage(THREE.DynamicDrawUsage); scene.add(fireflyInstanced);
const _ffDummy=new THREE.Object3D();
for(let i=0;i<FIREFLY_COUNT;i++){
  const angle=Math.random()*Math.PI*2,r=5+Math.random()*30;
  fireflies.push({offset:Math.random()*Math.PI*2,speed:.3+Math.random()*.5,radius:1+Math.random()*2,baseY:getGroundHeight(Math.cos(angle)*r,Math.sin(angle)*r)+2+Math.random()*4,orbitAngle:angle,orbitR:r});
}

// â”€â”€ Priority system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let currentPriority='med';

// â”€â”€ Tree skins â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const treeSkins={
  blossom:{
    label:'Blossom', emoji:'ğŸŒ¸',
    trunkColor:'#6d4c41', trunkTaper:true,
    leafColors:null, // null = use seasonInfo.treeColors
    leafSize:1.5, leafShape:'round',
    canopySpread:1.4, canopyLift:0.8, canopyVertSpread:2.5,
    emissiveIntensity:.45, lightColor:null,
  },
  jacaranda:{
    label:'Jacaranda', emoji:'ğŸ’œ',
    trunkColor:'#7a5c3a', trunkTaper:true,
    leafColors:['#9b59b6','#7d3c98','#c39bd3','#a569bd','#b07fe3'],
    leafSize:0.9, leafShape:'jacaranda',
    canopySpread:1.8, canopyLift:0.3, canopyVertSpread:1.8,
    emissiveIntensity:.55, lightColor:'#9b59b6',
  },
  pine:{
    label:'Pine', emoji:'ğŸŒ²',
    trunkColor:'#5d3a1a', trunkTaper:false,
    leafColors:['#1a5c2a','#2d7a3a','#145218','#1e6b30'],
    leafSize:1.1, leafShape:'spire',
    canopySpread:0.6, canopyLift:0, canopyVertSpread:1.2,
    emissiveIntensity:.2, lightColor:'#2d7a3a',
  },
  maple:{
    label:'Maple', emoji:'ğŸ',
    trunkColor:'#6b3a1f', trunkTaper:true,
    leafColors:['#c0392b','#e74c3c','#f39c12','#e67e22','#d35400'],
    leafSize:1.3, leafShape:'maple',
    canopySpread:1.4, canopyLift:0.6, canopyVertSpread:2.0,
    emissiveIntensity:.5, lightColor:'#e74c3c',
  },
};
let currentSkin='blossom';
const priConfigs={
  low:  {label:'Low',   trunkH:3.5, canopyR:1.2, leafCount:22, ringR:1.8, ringSpeed:.4, lightInt:10, treeScale:0.85},
  med:  {label:'Med',   trunkH:5.0, canopyR:1.5, leafCount:30, ringR:2.4, ringSpeed:.7, lightInt:16, treeScale:1.0},
  high: {label:'High',  trunkH:7.0, canopyR:1.9, leafCount:40, ringR:3.0, ringSpeed:1.4, lightInt:24, treeScale:1.2},
};
document.getElementById('pri-low').addEventListener('click',()=>setPriority('low'));
document.getElementById('pri-med').addEventListener('click',()=>setPriority('med'));
document.getElementById('pri-high').addEventListener('click',()=>setPriority('high'));
function setPriority(p){
  currentPriority=p;
  ['low','med','high'].forEach(x=>{ document.getElementById(`pri-${x}`).className='pri-btn'+(x===p?` active-${x}`:''); });
}
setPriority('med');

// â”€â”€ Skin selector â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.querySelectorAll('.skin-btn').forEach(btn=>{
  btn.addEventListener('click',()=>{
    currentSkin=btn.dataset.skin;
    document.querySelectorAll('.skin-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
  });
});

// â”€â”€ Tasks & state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let tasks=[], completedTasks=[], currentTab='active', selectedTree=null;
let volcanoLights=null;
const clock=new THREE.Clock();
const _v3=new THREE.Vector3();
const counterEl=document.getElementById('task-counter');
const tabContentEl=document.getElementById('tab-content');
const btnActive=document.getElementById('btn-active');
const btnHistory=document.getElementById('btn-history');
const bottomSheet=document.getElementById('bottom-sheet');
const inputBar=document.getElementById('input-bar');
const hint=document.getElementById('hint');
const deselectOvl=document.getElementById('deselect-overlay');

function openSheet()  { bottomSheet.classList.add('open'); inputBar.classList.add('hidden'); clearSelection(); deselectOvl.classList.remove('active'); }
function closeSheet() { bottomSheet.classList.remove('open'); inputBar.classList.remove('hidden'); }
counterEl.addEventListener('click',()=>bottomSheet.classList.contains('open')?closeSheet():openSheet());
document.getElementById('sheet-close').addEventListener('click',closeSheet);
btnActive.addEventListener('click',(e)=>{e.stopPropagation();switchTab('active');});
btnHistory.addEventListener('click',(e)=>{e.stopPropagation();switchTab('history');});

function switchTab(tab){ currentTab=tab; btnActive.classList.toggle('active',tab==='active'); btnHistory.classList.toggle('active',tab==='history'); updateUI(); }

function updateUI(){
  const isHistory=currentTab==='history',list=isHistory?completedTasks:tasks;
  counterEl.textContent=`ğŸŒ¸ ${tasks.length} Task${tasks.length!==1?'s':''}`;
  tabContentEl.innerHTML='';
  if(!list.length){ tabContentEl.innerHTML=`<div class="empty-state">No ${isHistory?'completed':'active'} tasks yet.</div>`; return; }
  list.forEach(task=>{
    const item=document.createElement('div');
    item.className=`task-list-item ${isHistory?'completed':''}`;
    const dv=isHistory?task.completedDate:task.date,dl=isHistory?'Completed':'Created';
    const p=task.priority||'med';
    item.innerHTML=`<div class="task-dot ${p}"></div>
      <div class="task-item-inner">
        <div class="name">${task.name}</div>
        <div class="meta">
          <span class="priority-badge ${p}">${priConfigs[p].label}</span>
          <span>${dl}: ${dv.toLocaleDateString()} ${dv.toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span>
        </div>
      </div>`;
    tabContentEl.appendChild(item);
  });
  counterEl.textContent=`ğŸŒ¸ ${tasks.length} Task${tasks.length!==1?'s':''}`;
}

// â”€â”€ localStorage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const LS_KEY='voxel_garden_tasks';
function saveTasks(){
  const data=tasks.map(t=>({id:t.id,name:t.name,priority:t.priority,skin:t.skin||'blossom',pos:{x:t.tree.position.x,y:t.tree.position.y,z:t.tree.position.z},date:t.date.toISOString()}));
  try{ localStorage.setItem(LS_KEY,JSON.stringify(data)); }catch(e){}
}
function saveCompleted(){
  const data=completedTasks.slice(0,50).map(t=>({id:t.id,name:t.name,priority:t.priority,date:t.date.toISOString(),completedDate:t.completedDate.toISOString()}));
  try{ localStorage.setItem(LS_KEY+'_done',JSON.stringify(data)); }catch(e){}
}
function loadSaved(){
  try{
    const raw=localStorage.getItem(LS_KEY);
    if(raw){
      JSON.parse(raw).forEach(d=>{ createBlossomTree(new THREE.Vector3(d.pos.x,d.pos.y,d.pos.z),d.name,d.priority||'med',new Date(d.date),d.skin||'blossom'); });
    }
    const rawDone=localStorage.getItem(LS_KEY+'_done');
    if(rawDone){
      completedTasks=JSON.parse(rawDone).map(d=>({...d,date:new Date(d.date),completedDate:new Date(d.completedDate)}));
    }
  }catch(e){}
  updateUI();
}

// â”€â”€ Seasonal colours â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getSeasonInfo(){
  const m=new Date().getMonth(); // 0-11
  if(m>=2&&m<=4)  return {name:'ğŸŒ¸ Spring', treeColors:['#ffb7c5','#f472b6','#e879f9','#c084fc','#fb7185'], grassTint:'#4a7c3f'};
  if(m>=5&&m<=7)  return {name:'ğŸŒ¿ Summer', treeColors:['#34d399','#4ade80','#a3e635','#86efac','#6ee7b7'], grassTint:'#3d7a35'};
  if(m>=8&&m<=10) return {name:'ğŸ‚ Autumn', treeColors:['#fb923c','#f59e0b','#ef4444','#dc2626','#d97706'], grassTint:'#6b5a38'};
  return                {name:'â„ï¸ Winter', treeColors:['#93c5fd','#bfdbfe','#e2e8f0','#c7d2fe','#ddd6fe'], grassTint:'#4a5568'};
}
let seasonInfo=getSeasonInfo();
document.getElementById('season-badge').textContent=seasonInfo.name;

// â”€â”€ Tree creation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function createBlossomTree(position, taskName, priority='med', plantedAt=null, skinKey=null){
  priority=priority||'med';
  const cfg=priConfigs[priority];
  const skin=treeSkins[skinKey||currentSkin]||treeSkins.blossom;
  const treeGroup=new THREE.Group();
  const id=THREE.MathUtils.generateUUID();
  treeGroup.userData={taskName,isTree:true,id,priority,skin:skinKey||currentSkin};

  treeGroup.scale.setScalar(cfg.treeScale);

  // â”€â”€ Trunk â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const trunkGeo=skin.trunkTaper
    ? new THREE.CylinderGeometry(0.35, 0.65, cfg.trunkH, 7)
    : new THREE.CylinderGeometry(0.5, 0.6, cfg.trunkH, 6);
  const trunk=new THREE.Mesh(trunkGeo, new THREE.MeshStandardMaterial({color:skin.trunkColor,roughness:.9}));
  trunk.position.y=cfg.trunkH/2; trunk.castShadow=true; treeGroup.add(trunk);

  // â”€â”€ Canopy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const palette=skin.leafColors||seasonInfo.treeColors;
  const hueHex=palette[Math.floor(Math.random()*palette.length)];
  const hue=new THREE.Color(hueHex);
  const leafMat=new THREE.MeshStandardMaterial({color:hue,emissive:hue,emissiveIntensity:skin.emissiveIntensity});

  // Helper: draw a cylinder between two Vector3 points
  const _up=new THREE.Vector3(0,1,0);
  function limb(a,b,r,mat){
    const dir=new THREE.Vector3().subVectors(b,a);
    const len=dir.length(); if(len<0.01) return;
    const mid=new THREE.Vector3().addVectors(a,b).multiplyScalar(.5);
    const mesh=new THREE.Mesh(new THREE.CylinderGeometry(r*.5,r,len,5),mat);
    mesh.position.copy(mid);
    mesh.quaternion.setFromUnitVectors(_up,dir.normalize());
    mesh.castShadow=true; treeGroup.add(mesh);
  }

  if(skin.leafShape==='spire'){
    // Pine: stacked conical tiers
    const tiers=3+Math.floor(cfg.leafCount/14);
    for(let ti=0;ti<tiers;ti++){
      const frac=ti/tiers;
      const tierR=cfg.canopyR*(1-frac*.55)+0.4;
      const tierY=cfg.trunkH*(0.45+frac*.5);
      const tierH=cfg.trunkH*0.38;
      const tierC=palette[ti%palette.length];
      const cone=new THREE.Mesh(
        new THREE.ConeGeometry(tierR,tierH,8),
        new THREE.MeshStandardMaterial({color:tierC,emissive:new THREE.Color(tierC),emissiveIntensity:skin.emissiveIntensity,roughness:.85})
      );
      cone.position.y=tierY; cone.castShadow=true; treeGroup.add(cone);
    }

  } else if(skin.leafShape==='jacaranda'){
    // Jacaranda: wide umbrella arms, flower clusters hanging at tips
    const branchMat=new THREE.MeshStandardMaterial({color:skin.trunkColor,roughness:.9});
    const armCount=5+Math.floor(cfg.canopyR);
    const armLen=cfg.canopyR*2.6;
    const tipSpread=.72; // sin of angle from vertical â€” high = flat arms
    const base=new THREE.Vector3(0,cfg.trunkH,0);
    for(let b=0;b<armCount;b++){
      const ang=(b/armCount)*Math.PI*2+(Math.random()-.5)*.3;
      // Arms sweep wide and slightly upward near trunk, then flatten at tip
      const tip=new THREE.Vector3(
        Math.cos(ang)*armLen*tipSpread,
        cfg.trunkH+armLen*(1-tipSpread)*.6+(Math.random()-.5)*.5,
        Math.sin(ang)*armLen*tipSpread
      );
      limb(base,tip,.22,branchMat);
      // Small secondary branch near tip
      const midPt=new THREE.Vector3().lerpVectors(base,tip,.65);
      const subAngle=ang+(Math.random()-.5)*.8;
      const subTip=new THREE.Vector3(
        tip.x+(Math.cos(subAngle)*.8),
        tip.y-(Math.random()*.6), // droop downward
        tip.z+(Math.sin(subAngle)*.8)
      );
      limb(midPt,subTip,.12,branchMat);

      // Flower clusters: spheres drooping below each tip
      const clusterN=4+Math.floor(Math.random()*3);
      for(let c=0;c<clusterN;c++){
        const col=palette[Math.floor(Math.random()*palette.length)];
        const sz=.55+Math.random()*.5;
        const fl=new THREE.Mesh(
          new THREE.SphereGeometry(sz,5,4),
          new THREE.MeshStandardMaterial({color:col,emissive:new THREE.Color(col),emissiveIntensity:skin.emissiveIntensity})
        );
        fl.position.set(
          tip.x+(Math.random()-.5)*1.4,
          tip.y-Math.random()*1.6,   // hang below tip
          tip.z+(Math.random()-.5)*1.4
        );
        fl.castShadow=true; treeGroup.add(fl);
      }
    }

  } else if(skin.leafShape==='maple'){
    // Maple: structured upright primary branches forking into sub-branches
    // with large dense leaf clusters at tips
    const branchMat=new THREE.MeshStandardMaterial({color:skin.trunkColor,roughness:.88});
    const primaryCount=4;
    const primaryLen=cfg.canopyR*1.5;
    const outLean=.50; // sin from vertical â€” moderate lean
    const base=new THREE.Vector3(0,cfg.trunkH*.75,0);
    for(let b=0;b<primaryCount;b++){
      const ang=(b/primaryCount)*Math.PI*2+(Math.random()-.5)*.25;
      const pTip=new THREE.Vector3(
        Math.cos(ang)*primaryLen*outLean,
        cfg.trunkH*.75+primaryLen*Math.sqrt(1-outLean*outLean),
        Math.sin(ang)*primaryLen*outLean
      );
      limb(base,pTip,.32,branchMat);

      // Each primary forks into 2 sub-branches
      for(let s=0;s<2;s++){
        const sAngle=ang+(s===0?-.45:.45);
        const sLen=primaryLen*.75;
        const sLean=outLean*.8;
        const sTip=new THREE.Vector3(
          pTip.x+Math.cos(sAngle)*sLen*sLean,
          pTip.y+sLen*Math.sqrt(1-sLean*sLean),
          pTip.z+Math.sin(sAngle)*sLen*sLean
        );
        limb(pTip,sTip,.16,branchMat);

        // Leaf cluster: 5-8 large chunky boxes tightly grouped at sub-tip
        const clusterN=5+Math.floor(Math.random()*4);
        for(let c=0;c<clusterN;c++){
          const col=palette[Math.floor(Math.random()*palette.length)];
          const sz=1.1+Math.random()*.9; // bigger, chunkier than blossom
          const lf=new THREE.Mesh(
            new THREE.BoxGeometry(sz,sz*(.7+Math.random()*.5),sz),
            new THREE.MeshStandardMaterial({color:col,emissive:new THREE.Color(col),emissiveIntensity:skin.emissiveIntensity})
          );
          lf.position.set(
            sTip.x+(Math.random()-.5)*1.6,
            sTip.y+(Math.random()-.5)*.9,
            sTip.z+(Math.random()-.5)*1.6
          );
          lf.rotation.set(Math.random()*.5,Math.random()*Math.PI,Math.random()*.5);
          lf.castShadow=true; treeGroup.add(lf);
        }
      }
    }

  } else {
    // Blossom: original round cloud canopy
    const leafGeo=new THREE.BoxGeometry(skin.leafSize,skin.leafSize,skin.leafSize);
    for(let i=0;i<cfg.leafCount;i++){
      const leafColor=palette[Math.floor(Math.random()*palette.length)];
      const lMat=new THREE.MeshStandardMaterial({color:leafColor,emissive:new THREE.Color(leafColor),emissiveIntensity:skin.emissiveIntensity});
      const leaf=new THREE.Mesh(leafGeo,lMat);
      const r=cfg.canopyR*skin.canopySpread*(.6+Math.random()*.8);
      const ang=Math.random()*Math.PI*2;
      leaf.position.set(Math.cos(ang)*r,cfg.trunkH+skin.canopyLift+(Math.random()-.5)*skin.canopyVertSpread,Math.sin(ang)*r);
      leaf.rotation.set(Math.random(),Math.random(),Math.random()); leaf.castShadow=true; treeGroup.add(leaf);
    }
  }

  // â”€â”€ Canopy light â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const lightCol=skin.lightColor?new THREE.Color(skin.lightColor):hue;
  const treeLight=new THREE.PointLight(lightCol,cfg.lightInt,14); treeLight.position.y=cfg.trunkH+3; treeGroup.add(treeLight);

  treeGroup.position.copy(position); scene.add(treeGroup);

  // â”€â”€ CSS2D label â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const wrapper=document.createElement('div'); wrapper.className=`tree-label priority-${priority}`;
  const bubble=document.createElement('div'); bubble.className=`tree-label-bubble`;
  const dot=document.createElement('div'); dot.className='priority-dot';
  const nameSpan=document.createElement('span'); nameSpan.textContent=taskName;
  bubble.appendChild(dot); bubble.appendChild(nameSpan);
  const stem=document.createElement('div'); stem.className='tree-label-stem';
  const confirmBtn=document.createElement('button'); confirmBtn.className='tree-label-confirm'; confirmBtn.textContent='âœ“ Complete';
  // Use both pointerdown AND click for maximum compatibility
  const doComplete=(e)=>{ e.preventDefault(); e.stopPropagation(); completeTree(treeGroup); };
  confirmBtn.addEventListener('pointerdown', doComplete);
  confirmBtn.addEventListener('click', doComplete);
  wrapper.appendChild(bubble); wrapper.appendChild(stem); wrapper.appendChild(confirmBtn);

  const doBubbleSelect=(e)=>{ e.preventDefault(); e.stopPropagation(); handleTreeSelect(treeGroup); };
  bubble.addEventListener('pointerdown', doBubbleSelect);
  bubble.addEventListener('click', doBubbleSelect);

  const label=new CSS2DObject(wrapper);
  label.position.set(0, cfg.trunkH+7, 0);
  treeGroup.add(label);
  treeGroup.userData.labelWrapper=wrapper; treeGroup.userData.labelBubble=bubble;

  const now=plantedAt||new Date();
  tasks.push({tree:treeGroup,name:taskName,priority,date:now,id,baseScale:cfg.treeScale,skin:skinKey||currentSkin});
  saveTasks(); updateUI();
  showHint();
}

// â”€â”€ Selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleTreeSelect(treeGroup){
  if(selectedTree===treeGroup){ completeTree(treeGroup); return; }
  clearSelection();
  selectedTree=treeGroup;
  treeGroup.userData.labelWrapper?.classList.add('selected');
  treeGroup.userData.labelBubble?.classList.add('selected');
  const task=tasks.find(t=>t.id===treeGroup.userData.id);
  treeGroup.scale.setScalar((task?.baseScale||1)*1.12);
  deselectOvl.classList.add('active');
}

function clearSelection(){
  if(selectedTree){
    selectedTree.userData.labelWrapper?.classList.remove('selected');
    selectedTree.userData.labelBubble?.classList.remove('selected');
    const task=tasks.find(t=>t.id===selectedTree.userData.id);
    selectedTree.scale.setScalar(task?.baseScale||1);
    selectedTree=null;
  }
  deselectOvl.classList.remove('active');
}
deselectOvl.addEventListener('pointerdown', clearSelection);

// â”€â”€ Complete â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const fallingBlocks=[];
function completeTree(tree){
  const idx=tasks.findIndex(t=>t.id===tree.userData.id);
  if(idx===-1) return;
  completedTasks.unshift({...tasks.splice(idx,1)[0], completedDate:new Date()});
  clearSelection();
  // Remove CSS2D label from DOM before removing tree â€” CSS2DRenderer doesn't auto-clean
  tree.children.slice().forEach(child=>{
    if(child.isCSS2DObject){ child.element?.remove(); tree.remove(child); }
  });
  tree.children.forEach(child=>{
    if(!child.isMesh||child.userData.isRing) return;
    const block={mesh:child.clone(),velocity:new THREE.Vector3((Math.random()-.5)*4,Math.random()*6+2,(Math.random()-.5)*4),rotation:new THREE.Vector3(Math.random(),Math.random(),Math.random()).multiplyScalar(.12),life:80};
    block.mesh.position.copy(child.getWorldPosition(new THREE.Vector3())); scene.add(block.mesh); fallingBlocks.push(block);
  });
  scene.remove(tree); saveTasks(); saveCompleted(); updateUI();
}

// â”€â”€ Plant task â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('plantBtn').addEventListener('click',plantTask);
document.getElementById('taskInput').addEventListener('keydown',(e)=>{if(e.key==='Enter'){e.preventDefault();plantTask();}});
function plantTask(){
  const input=document.getElementById('taskInput'),val=input.value.trim(); if(!val) return;
  let pos=null,attempts=0;
  while(!pos&&attempts++<100){const x=(Math.random()-.5)*56,z=(Math.random()-.5)*56,y=getGroundHeight(x,z);if(y>2)pos=new THREE.Vector3(x,y+.5,z);}
  if(pos){createBlossomTree(pos,val,currentPriority);input.value='';input.blur();closeSheet();}
}

// â”€â”€ Hint â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let hintTimer=null;
function showHint(){clearTimeout(hintTimer);hint.classList.remove('hidden');hintTimer=setTimeout(()=>hint.classList.add('hidden'),3500);}
showHint();

// â”€â”€ Raycaster â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const raycaster=new THREE.Raycaster(),pointer=new THREE.Vector2();
let frameCount=0;
function getTreeFromHits(hits){for(const h of hits){let o=h.object;while(o.parent&&!o.userData.isTree)o=o.parent;if(o.userData.isTree)return o;}return null;}

window.addEventListener('mousemove',(e)=>{pointer.x=(e.clientX/window.innerWidth)*2-1;pointer.y=-(e.clientY/window.innerHeight)*2+1;});
window.addEventListener('click',(e)=>{
  if(bottomSheet.classList.contains('open')) return;
  pointer.x=(e.clientX/window.innerWidth)*2-1; pointer.y=-(e.clientY/window.innerHeight)*2+1;
  raycaster.setFromCamera(pointer,camera);
  const tree=getTreeFromHits(raycaster.intersectObjects(tasks.map(t=>t.tree),true));
  tree?handleTreeSelect(tree):clearSelection();
});
let touchSX=0,touchSY=0;
window.addEventListener('touchstart',(e)=>{touchSX=e.touches[0].clientX;touchSY=e.touches[0].clientY;},{passive:true});
window.addEventListener('touchend',(e)=>{
  if(bottomSheet.classList.contains('open')) return;
  const dx=Math.abs(e.changedTouches[0].clientX-touchSX),dy=Math.abs(e.changedTouches[0].clientY-touchSY);
  if(dx>12||dy>12) return;
  const t=e.changedTouches[0];
  pointer.x=(t.clientX/window.innerWidth)*2-1; pointer.y=-(t.clientY/window.innerHeight)*2+1;
  raycaster.setFromCamera(pointer,camera);
  const tree=getTreeFromHits(raycaster.intersectObjects(tasks.map(t=>t.tree),true));
  tree?handleTreeSelect(tree):clearSelection();
},{passive:true});

// â”€â”€ Ambient Sound (Web Audio API â€” fully self-contained) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€ Audio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let audioCtx=null, soundOn=false, _fadeTimeout=null;
let _masterGain=null, _melodyGain=null, _droneGain=null;
let _droneOscs=[], _melodyTimeout=null;
let _userVolume=0.55; // 0â€“1

const soundBtn=document.getElementById('sound-btn');
soundBtn.addEventListener('click',toggleSound);

// Volume control widget â€” injected after sound btn
const volWidget=document.createElement('div');
volWidget.id='vol-widget';
volWidget.innerHTML=`<input type="range" id="vol-slider" min="0" max="1" step="0.01" value="${_userVolume}">`;
document.body.appendChild(volWidget);

async function toggleSound(){
  if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
  if(audioCtx.state==='suspended') await audioCtx.resume();
  soundOn=!soundOn;
  soundBtn.textContent=soundOn?'ğŸµ':'ğŸ”‡';
  volWidget.classList.toggle('visible', soundOn);
  volWidget.classList.remove('dimmed');
  if(soundOn) { _startMusic(); _scheduleDim(); } else _stopMusic(true);
}

let _dimTimer=null;
function _scheduleDim(){
  clearTimeout(_dimTimer);
  volWidget.classList.remove('dimmed');
  _dimTimer=setTimeout(()=>{ if(soundOn) volWidget.classList.add('dimmed'); }, 3000);
}
document.getElementById('vol-slider')?.addEventListener('input', e=>{
  _userVolume=parseFloat(e.target.value);
  if(_masterGain && audioCtx) _masterGain.gain.setTargetAtTime(_userVolume, audioCtx.currentTime, 0.05);
  _scheduleDim();
});
volWidget.addEventListener('mouseenter',()=>{ clearTimeout(_dimTimer); volWidget.classList.remove('dimmed'); });
volWidget.addEventListener('mouseleave',()=>{ if(soundOn) _scheduleDim(); });

// C pentatonic: C3 D E G A C4 D E G A C5 â€¦
const PENTA_FREQS=[130.81,146.83,164.81,196.00,220.00,261.63,293.66,329.63,392.00,440.00,523.25];
// Gentle note sequence (indices into PENTA_FREQS) â€” loops
const MELODY=[0,2,4,3,5,4,2,1,0,4,5,4,2,0,1,2,4,5,3,1];
let _melIdx=0;

function _startMusic(){
  _stopMusic(false);
  clearTimeout(_fadeTimeout);

  // Master gain
  _masterGain=audioCtx.createGain();
  _masterGain.gain.setValueAtTime(0, audioCtx.currentTime);
  _masterGain.gain.linearRampToValueAtTime(_userVolume, audioCtx.currentTime+2.5);
  _masterGain.connect(audioCtx.destination);

  // â”€â”€ Rain layer â€” lowpass-filtered white noise sounds like soft rainfall â”€â”€â”€â”€â”€â”€
  _droneGain=audioCtx.createGain(); _droneGain.gain.value=0.28;
  _droneGain.connect(_masterGain);
  // Build a 4s looping white noise buffer
  const sr=audioCtx.sampleRate, bufSec=4, bufSize=sr*bufSec;
  const buf=audioCtx.createBuffer(1,bufSize,sr);
  const data=buf.getChannelData(0);
  for(let i=0;i<bufSize;i++) data[i]=Math.random()*2-1;
  const rain=audioCtx.createBufferSource(); rain.buffer=buf; rain.loop=true;
  // Two cascaded lowpass filters to shape into a soft rain texture
  const lp1=audioCtx.createBiquadFilter(); lp1.type='lowpass'; lp1.frequency.value=1800; lp1.Q.value=0.3;
  const lp2=audioCtx.createBiquadFilter(); lp2.type='lowpass'; lp2.frequency.value=900;  lp2.Q.value=0.5;
  // Highpass to remove rumble
  const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=220; hp.Q.value=0.4;
  rain.connect(hp); hp.connect(lp1); lp1.connect(lp2); lp2.connect(_droneGain);
  rain.start();
  _droneOscs=[rain]; // reuse array for cleanup

  // â”€â”€ Melody layer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _melodyGain=audioCtx.createGain(); _melodyGain.gain.value=0.55;
  _melodyGain.connect(_masterGain);
  _melIdx=0;
  _scheduleNote();
}

function _scheduleNote(){
  if(!soundOn||!audioCtx||!_melodyGain) return;
  const freq=PENTA_FREQS[MELODY[_melIdx % MELODY.length]];
  _melIdx++;

  const now=audioCtx.currentTime;
  const osc=audioCtx.createOscillator();
  const env=audioCtx.createGain();
  // Slight reverb via convolver would be nice but for lightness use a short delay
  osc.type='sine'; osc.frequency.value=freq;
  env.gain.setValueAtTime(0, now);
  env.gain.linearRampToValueAtTime(0.22, now+0.06);   // soft attack
  env.gain.setTargetAtTime(0, now+0.06, 0.45);         // natural decay
  osc.connect(env); env.connect(_melodyGain);
  osc.start(now); osc.stop(now+2.5);

  // Vary note spacing 1.4â€“2.8s for a wandering meditative feel
  const gap=(1.4+Math.random()*1.4)*1000;
  _melodyTimeout=setTimeout(_scheduleNote, gap);
}

function _stopMusic(fade=true){
  clearTimeout(_melodyTimeout); _melodyTimeout=null;
  if(_masterGain){
    const mg=_masterGain, drones=[..._droneOscs];
    _masterGain=null; _melodyGain=null; _droneGain=null; _droneOscs=[];
    clearTimeout(_fadeTimeout);
    if(fade){
      mg.gain.cancelScheduledValues(audioCtx.currentTime);
      mg.gain.setValueAtTime(mg.gain.value, audioCtx.currentTime);
      mg.gain.linearRampToValueAtTime(0, audioCtx.currentTime+1.8);
      _fadeTimeout=setTimeout(()=>{ drones.forEach(o=>{try{o.stop();o.disconnect();}catch(e){}}); try{mg.disconnect();}catch(e){} },2000);
    } else {
      drones.forEach(o=>{try{o.stop();o.disconnect();}catch(e){}});
      try{mg.disconnect();}catch(e){}
    }
  } else { _droneOscs=[]; }
}

// â”€â”€ Time-of-day â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function sStep(a,b,x){const t=Math.max(0,Math.min(1,(x-a)/(b-a)));return t*t*(3-2*t);}
function lc(h1,h2,t){return new THREE.Color().lerpColors(new THREE.Color(h1),new THREE.Color(h2),Math.max(0,Math.min(1,t)));}
let currentNightness=0; // updated every minute by applyTimeOfDay, used by animate loop
function applyTimeOfDay(){
  const now=new Date(),hour=now.getHours()+now.getMinutes()/60;
  let dayness; if(hour<5)dayness=0;else if(hour<7)dayness=sStep(5,7,hour);else if(hour<18)dayness=1;else if(hour<20)dayness=1-sStep(18,20,hour);else dayness=0;
  const nightness=1-dayness,dawnness=sStep(4.5,6,hour)*(1-sStep(6,7.5,hour)),duskness=sStep(17,19,hour)*(1-sStep(19,21,hour)),golden=Math.max(dawnness,duskness);
  currentNightness=nightness;
  let sky=lc('#00001a','#2a6faa',dayness); if(golden>.01)sky.lerp(new THREE.Color('#d4580a'),golden*.75); if(dawnness>.01)sky.lerp(new THREE.Color('#1a0830'),dawnness*.35);
  scene.background=sky; scene.fog.color.copy(sky);
  let hSky=lc('#1a1a4e','#6ab4f5',dayness); if(golden>0)hSky.lerp(new THREE.Color('#ff8844'),golden*.55);
  hemiLight.color.copy(hSky); hemiLight.groundColor.set(dayness>.5?0x4a7c3f:0x0d1a0d); hemiLight.intensity=.8+dayness*1.6;
  let amb=lc('#304090','#8ab4e8',dayness); if(golden>0)amb.lerp(new THREE.Color('#c06030'),golden*.65);
  ambientLight.color.copy(amb); ambientLight.intensity=.5+dayness*1.3;
  const sunAngle=((hour-6)/12)*Math.PI,sunX=Math.cos(sunAngle)*100,sunY=Math.abs(Math.sin(sunAngle))*90+8,sunZ=-60;
  let kColor=lc('#ff9944','#fffcee',dayness); if(golden>.2)kColor.lerp(new THREE.Color('#ff7722'),golden*.7); kColor.lerp(new THREE.Color('#c8d8ff'),nightness*.9);
  keyLight.color.copy(kColor); keyLight.intensity=dayness*2.8+golden*.8+nightness*2.2;
  keyLight.position.set(sunX*dayness+(-50)*nightness,sunY*dayness+70*nightness,sunZ*dayness+40*nightness);
  rimLight.color.set(dayness>.5?0x305090:0x6030a0); rimLight.intensity=.3+dayness*.45;
  sunMesh.visible=dayness>.02;
  if(sunMesh.visible){sunMesh.position.set(sunX*2.6,sunY*2.6,sunZ*2.6);sunMat.emissive.set(golden>.3?0xff7722:0xffee55);sunMat.color.set(golden>.3?0xff9944:0xfffbe0);sunMat.emissiveIntensity=2.5+golden*3;sunGlow.position.copy(sunMesh.position);sunGlow.intensity=dayness*120+golden*80;sunGlow.color.set(golden>.3?0xff8833:0xffeebb);}else{sunGlow.intensity=0;}
  moonMesh.visible=nightness>.08; moonGlow.intensity=nightness*28; moonGlow.color.set(0x99aad4);
  starPoints.material.opacity=Math.max(0,Math.min(1, nightness*1.6-dayness*1.2));
  const ffStr=Math.min(6,nightness*10); fireflyClusterA.intensity=ffStr; fireflyClusterB.intensity=ffStr;
  renderer.toneMappingExposure=.65+dayness*.55;
  const badge=document.getElementById('time-badge');
  if(badge){const ts=now.toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'});let phase;if(hour>=21||hour<5)phase='\u{1F319} Night';else if(hour<7)phase='\u{1F305} Dawn';else if(hour<18)phase='\u2600\uFE0F Day';else phase='\u{1F307} Dusk';badge.textContent=phase+' \u00B7 '+ts;}
}

// â”€â”€ Animation loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€ Frog â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Pre-defined waypoints around the island (world x,z â€” y sampled at runtime)
const FROG_WAYPOINTS=[
  [4,2],[8,6],[10,10],[6,14],[2,16],[-4,12],[-8,6],[-8,-2],[-4,-8],[2,-10],[8,-6],[4,2]
];
let frog=null, frogWpIdx=0, frogHopT=0, frogHopping=false;
let frogFrom=new THREE.Vector3(), frogTo=new THREE.Vector3();

function createFrog(){
  const g=new THREE.Group();
  const skin=new THREE.MeshStandardMaterial({color:'#c2622d',roughness:.85});
  const darkSkin=new THREE.MeshStandardMaterial({color:'#8a3c18',roughness:.88});
  const eyeWhite=new THREE.MeshStandardMaterial({color:'#e8e8d0',roughness:.6});
  const eyePupil=new THREE.MeshStandardMaterial({color:'#1a1a1a',roughness:.5});
  const belly=new THREE.MeshStandardMaterial({color:'#e8956a',roughness:.9});

  // Body
  const body=new THREE.Mesh(new THREE.BoxGeometry(1,.7,1.1),skin); body.position.y=.35;
  // Belly patch
  const bel=new THREE.Mesh(new THREE.BoxGeometry(.6,.3,.5),belly); bel.position.set(0,.22,.3);
  // Head
  const head=new THREE.Mesh(new THREE.BoxGeometry(.9,.55,.75),skin); head.position.set(0,.72,.5);
  // Eyes â€” bulging on top of head
  [-0.28,0.28].forEach(ex=>{
    const eyeBase=new THREE.Mesh(new THREE.BoxGeometry(.10,.10,.10),eyeWhite); eyeBase.position.set(ex,1.00,.52);
    const pupil=new THREE.Mesh(new THREE.BoxGeometry(.05,.06,.05),eyePupil); pupil.position.set(ex,1.00,.57);
    g.add(eyeBase,pupil);
  });
  // Front legs
  [-0.48,0.48].forEach(lx=>{
    const upper=new THREE.Mesh(new THREE.BoxGeometry(.22,.18,.42),darkSkin); upper.position.set(lx,.2,.45);
    const lower=new THREE.Mesh(new THREE.BoxGeometry(.38,.12,.18),darkSkin); lower.position.set(lx*1.15,.08,.68);
    g.add(upper,lower);
  });
  // Back legs â€” splayed out
  [-0.52,0.52].forEach(lx=>{
    const thigh=new THREE.Mesh(new THREE.BoxGeometry(.22,.2,.5),darkSkin); thigh.position.set(lx,.2,-.32);
    const shin=new THREE.Mesh(new THREE.BoxGeometry(.2,.16,.42),darkSkin); shin.position.set(lx*1.2,.1,-.62);
    const foot=new THREE.Mesh(new THREE.BoxGeometry(.4,.1,.2),darkSkin); foot.position.set(lx*1.3,.06,-.76);
    g.add(thigh,shin,foot);
  });

  g.add(body,bel,head);
  g.scale.setScalar(.55); // keep it small and cute

  // Start at first waypoint
  const [wx,wz]=FROG_WAYPOINTS[0];
  const wy=getGroundHeight(wx,wz);
  g.position.set(wx,wy,wz);
  frogFrom.set(wx,wy,wz);
  frogTo.set(wx,wy,wz);

  scene.add(g);
  frog=g;

  // Kick off hop cycle â€” pause 2.5-4.5s between hops
  scheduleFrogHop();
}

function scheduleFrogHop(){
  const pause=8000+Math.random()*10000;
  setTimeout(()=>{ startFrogHop(); },pause);
}

function startFrogHop(){
  if(!frog) return;
  frogWpIdx=(frogWpIdx+1)%FROG_WAYPOINTS.length;
  const [tx,tz]=FROG_WAYPOINTS[frogWpIdx];
  const ty=getGroundHeight(tx,tz);
  frogFrom.copy(frog.position);
  frogTo.set(tx,ty,tz);
  // Face direction of travel
  frog.rotation.y=Math.atan2(tx-frogFrom.x, tz-frogFrom.z);
  frogHopT=0; frogHopping=true;
}

function tickFrog(delta){
  if(!frog||!frogHopping) return;
  frogHopT=Math.min(frogHopT+delta*2.2,1); // hop duration ~0.45s
  const t=frogHopT;
  // Gravity-like arc: rises quickly, falls faster (asymmetric parabola)
  const arc=t<0.4 ? (t/0.4) : (1-(t-0.4)/0.6); // fast up, slower fall
  const gravity=arc*arc; // squash the peak â€” quadratic feels earthlike
  frog.position.x=frogFrom.x+(frogTo.x-frogFrom.x)*t;
  frog.position.z=frogFrom.z+(frogTo.z-frogFrom.z)*t;
  frog.position.y=frogFrom.y+(frogTo.y-frogFrom.y)*t + gravity*0.35;
  // Tilt forward on ascent, back on descent
  frog.rotation.x=gravity*-.18;
  if(frogHopT>=1){
    frog.position.copy(frogTo); frog.rotation.x=0;
    frogHopping=false; scheduleFrogHop();
  }
}

// â”€â”€ Calico cat (Cali) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€ Cat route: scenic spots with long sit times (~1hr full loop) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Each entry: [x, z, sitSecs, label]
// Travel between spots: ~30-90s depending on distance (walkSpeed controls this)
// Total sit time: ~3000s + travel â‰ˆ ~60min loop
const CAT_SPOTS=[
  {x:3,   z:3,   sit:420, label:'peak bench'},      // torii peak â€” sits by the bench
  {x:-6,  z:10,  sit:300, label:'shrine steps'},   // north shrine entrance
  {x:14,  z:-4,  sit:480, label:'sunny slope'},     // south-east sunny slope
  {x:22,  z:8,   sit:360, label:'flower patch'},    // flower patch area
  {x:26,  z:22,  sit:240, label:'beach torii'},     // shore torii, watches the ocean
  {x:16,  z:18,  sit:180, label:'cushion'},         // sleeping cushion spot
  {x:-10, z:6,   sit:420, label:'bamboo shade'},    // bamboo grove shade
  {x:-18, z:-4,  sit:300, label:'west rocks'},      // rocky outcrop west
  {x:4,   z:-14, sit:360, label:'south path'},      // stone path mid-point
  {x:10,  z:2,   sit:240, label:'lamp post'},       // lamp post nap
];
let cat=null, catTail=null, catWpIdx=0;
// States: 'walking' | 'settling' | 'sitting' | 'rising'
let catState='sitting', catWalkT=0, catStateT=0;
let catFrom=new THREE.Vector3(), catTo=new THREE.Vector3();
let catSitRemaining=0;

function createCat(){
  const g=new THREE.Group();

  // Calico palette
  const white  =new THREE.MeshStandardMaterial({color:'#f5f0eb',roughness:.9});
  const orange =new THREE.MeshStandardMaterial({color:'#d4682a',roughness:.88});
  const black  =new THREE.MeshStandardMaterial({color:'#1c1612',roughness:.9});
  const pink   =new THREE.MeshStandardMaterial({color:'#e8a0a0',roughness:.8});
  const eyeCol =new THREE.MeshStandardMaterial({color:'#d4a017',emissive:'#a07010',emissiveIntensity:.6,roughness:.4}); // amber eyes
  const pupilM =new THREE.MeshStandardMaterial({color:'#0a0806',roughness:.5});

  // â”€â”€ Body â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const body=new THREE.Mesh(new THREE.BoxGeometry(1.1,.72,1.6),white);
  body.position.y=.6;
  // Orange saddle patch on back
  const saddle=new THREE.Mesh(new THREE.BoxGeometry(.8,.22,.9),orange);
  saddle.position.set(0,.98,-.1);
  // Black flank patch â€” left side
  const flank=new THREE.Mesh(new THREE.BoxGeometry(.18,.5,.65),black);
  flank.position.set(-.54,.72,-.15);
  g.add(body,saddle,flank);

  // â”€â”€ Neck â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const neck=new THREE.Mesh(new THREE.BoxGeometry(.58,.5,.5),white);
  neck.position.set(0,.82,.72);
  g.add(neck);

  // â”€â”€ Head â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const head=new THREE.Mesh(new THREE.BoxGeometry(.82,.7,.72),white);
  head.position.set(0,1.08,1.08);
  // Black mask patch over left eye+ear area
  const mask=new THREE.Mesh(new THREE.BoxGeometry(.36,.45,.18),black);
  mask.position.set(-.28,1.2,1.16);
  // Orange patch on top of head
  const headPatch=new THREE.Mesh(new THREE.BoxGeometry(.5,.18,.4),orange);
  headPatch.position.set(.08,1.42,1.0);
  // Muzzle
  const muzzle=new THREE.Mesh(new THREE.BoxGeometry(.44,.3,.22),white);
  muzzle.position.set(0,.92,1.4);
  // Pink nose
  const nose=new THREE.Mesh(new THREE.BoxGeometry(.12,.1,.08),pink);
  nose.position.set(0,.98,1.5);
  g.add(head,mask,headPatch,muzzle,nose);

  // â”€â”€ Ears â€” pointed wedges (tall thin boxes, tilted) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  [-0.28,0.28].forEach((ex,ei)=>{
    const ear=new THREE.Mesh(new THREE.BoxGeometry(.18,.36,.08),ei===0?black:white);
    ear.position.set(ex,1.48,1.02);
    ear.rotation.z=ex<0?-.25:.25; // splay outward
    g.add(ear);
  });

  // â”€â”€ Eyes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  [-0.22,0.22].forEach(ex=>{
    const eye=new THREE.Mesh(new THREE.BoxGeometry(.16,.14,.1),eyeCol);
    eye.position.set(ex,1.14,1.44);
    const pupil=new THREE.Mesh(new THREE.BoxGeometry(.07,.12,.06),pupilM);
    pupil.position.set(ex,1.14,1.48);
    g.add(eye,pupil);
  });

  // â”€â”€ Legs â€” pivot groups so we can rotate at the hip joint â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Order: [front-left, front-right, back-left, back-right]
  const catLegs=[];
  const legDefs=[[-0.38,-.55],[ 0.38,-.55],[-0.38,.55],[ 0.38,.55]];
  legDefs.forEach(([lx,lz],li)=>{
    const pivot=new THREE.Group();
    pivot.position.set(lx,.52,lz); // hip position on body
    const col=li===0?orange:white;
    const upper=new THREE.Mesh(new THREE.BoxGeometry(.28,.34,.28),col);
    upper.position.y=-.17; // hang below pivot
    const lower=new THREE.Mesh(new THREE.BoxGeometry(.24,.24,.28),white);
    lower.position.y=-.44;
    const paw=new THREE.Mesh(new THREE.BoxGeometry(.3,.12,.34),white);
    paw.position.set(0,-.58,.04);
    pivot.add(upper,lower,paw);
    g.add(pivot);
    catLegs.push(pivot);
  });

  // â”€â”€ Tail â€” segmented curve arching upward â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const tailGroup=new THREE.Group();
  const tailSegs=5;
  for(let i=0;i<tailSegs;i++){
    const frac=i/tailSegs;
    const segW=.22*(1-frac*.3);
    const col=i===2||i===4?orange:white; // calico patches on tail
    const seg=new THREE.Mesh(new THREE.BoxGeometry(segW,.28,segW),col);
    // Arc: segments go backward then curl up
    seg.position.set(0, frac*1.1, -(0.32+frac*.55));
    seg.rotation.x=.3+frac*.45; // progressive forward tilt = upward curl
    tailGroup.add(seg);
  }
  tailGroup.position.set(0,.7,-.8);
  g.add(tailGroup);
  catTail=tailGroup;

  g.scale.setScalar(.52);
  g.userData.legs=catLegs;

  const spot=CAT_SPOTS[0];
  const wy=getGroundHeight(spot.x,spot.z);
  g.position.set(spot.x,wy+0.28,spot.z);
  catFrom.set(spot.x,wy+0.28,spot.z);
  catTo.set(spot.x,wy+0.28,spot.z);
  catSitRemaining=spot.sit;
  catState='sitting';

  scene.add(g);
  cat=g;
}

function tickCat(delta, elapsed){
  if(!cat) return;
  const legs=cat.userData.legs;

  // Tail sway â€” always, slower when sitting
  const tailAmp=catState==='sitting'?0.18:0.38;
  const tailSpeed=catState==='sitting'?0.6:1.0;
  if(catTail) catTail.rotation.y=Math.sin(elapsed*tailSpeed)*tailAmp;

  catStateT+=delta;

  if(catState==='sitting'){
    // Tucked pose: body lowered, legs folded under
    cat.position.y=THREE.MathUtils.lerp(cat.position.y, _catGroundY()+0.08, 0.06);
    if(legs){ legs.forEach((l,i)=>{ l.rotation.x=THREE.MathUtils.lerp(l.rotation.x, i<2?0.55:0.45, 0.08); }); }

    catSitRemaining-=delta;
    if(catSitRemaining<=0){
      // Time to move â€” rise first
      catState='rising'; catStateT=0;
    }

  } else if(catState==='rising'){
    // ~1.2s to stand up: legs unfold
    const t=Math.min(catStateT/1.2,1);
    if(legs){ legs.forEach(l=>{ l.rotation.x=THREE.MathUtils.lerp(l.rotation.x,0,0.12); }); }
    cat.position.y=THREE.MathUtils.lerp(cat.position.y, _catGroundY()+0.28, 0.08);
    if(t>=1){
      // Pick next spot
      catWpIdx=(catWpIdx+1)%CAT_SPOTS.length;
      const spot=CAT_SPOTS[catWpIdx];
      const ty=getGroundHeight(spot.x,spot.z);
      catFrom.copy(cat.position);
      catTo.set(spot.x,ty+0.28,spot.z);
      cat.rotation.y=Math.atan2(spot.x-catFrom.x, spot.z-catFrom.z);
      catWalkT=0; catState='walking'; catStateT=0;
    }

  } else if(catState==='walking'){
    // Distance-based walk speed: ~2 units/sec in world space (slow, dignified)
    const dist=catFrom.distanceTo(catTo);
    const duration=Math.max(dist/2, 4); // min 4s even for short hops
    catWalkT=Math.min(catWalkT+delta/duration,1);
    const t=catWalkT;

    cat.position.x=THREE.MathUtils.lerp(catFrom.x,catTo.x,t);
    cat.position.z=THREE.MathUtils.lerp(catFrom.z,catTo.z,t);

    // Leg swing â€” diagonal pairs (trot gait)
    const swing=Math.sin(elapsed*6)*0.44;
    if(legs){
      legs[0].rotation.x= swing;
      legs[3].rotation.x= swing;
      legs[1].rotation.x=-swing;
      legs[2].rotation.x=-swing;
    }

    // Ground + body bob
    const groundY=getGroundHeight(Math.round(cat.position.x),Math.round(cat.position.z));
    const bob=Math.abs(Math.sin(elapsed*6))*0.05;
    cat.position.y=THREE.MathUtils.lerp(cat.position.y, groundY+0.28+bob, 0.2);

    if(catWalkT>=1){
      cat.position.x=catTo.x; cat.position.z=catTo.z;
      if(legs) legs.forEach(l=>{ l.rotation.x=0; });
      // Settle into sitting
      const spot=CAT_SPOTS[catWpIdx];
      catSitRemaining=spot.sit;
      catState='settling'; catStateT=0;
    }

  } else if(catState==='settling'){
    // ~0.8s to sit down â€” turn to face a nice direction, body lowers
    const t=Math.min(catStateT/0.8,1);
    cat.position.y=THREE.MathUtils.lerp(cat.position.y, _catGroundY()+0.08, 0.07);
    if(t>=1){ catState='sitting'; catStateT=0; }
  }
}

function _catGroundY(){
  if(!cat) return 0;
  return getGroundHeight(Math.round(cat.position.x),Math.round(cat.position.z));
}

function animate(){
  requestAnimationFrame(animate);
  const delta=clock.getDelta(),elapsed=clock.getElapsedTime();

  // Burst blocks
  for(let i=fallingBlocks.length-1;i>=0;i--){
    const b=fallingBlocks[i]; b.velocity.y-=9.8*delta;
    _v3.copy(b.velocity).multiplyScalar(delta); b.mesh.position.add(_v3);
    b.mesh.rotation.x+=b.rotation.x; b.mesh.rotation.y+=b.rotation.y; b.life-=delta*60;
    if(b.life<=0){scene.remove(b.mesh);fallingBlocks.splice(i,1);}
  }

  // Fireflies
  let brightest=0;
  for(let i=0;i<fireflies.length;i++){
    const ff=fireflies[i],t=elapsed*ff.speed+ff.offset,b=(Math.sin(t*1.3)*.5+.5)*(Math.sin(t*.7)*.5+.5);
    ff.orbitAngle+=delta*.15*ff.speed;
    _ffDummy.position.set(Math.cos(ff.orbitAngle)*ff.orbitR+Math.sin(t*.4)*ff.radius,ff.baseY+Math.sin(t)*1.2,Math.sin(ff.orbitAngle)*ff.orbitR+Math.cos(t*.4)*ff.radius);
    _ffDummy.scale.setScalar(.5+b*1.5); _ffDummy.updateMatrix(); fireflyInstanced.setMatrixAt(i,_ffDummy.matrix);
    if(b>brightest)brightest=b;
  }
  fireflyInstanced.material.emissiveIntensity=1+brightest*4; fireflyInstanced.instanceMatrix.needsUpdate=true;
  fireflyClusterA.position.set(Math.sin(elapsed*.17)*18,4+Math.sin(elapsed*.3)*2,Math.cos(elapsed*.13)*18);
  fireflyClusterB.position.set(Math.sin(elapsed*.11+2)*14,5+Math.cos(elapsed*.25)*2,Math.cos(elapsed*.19+1)*14);

  // Volcano lava flicker â€” subtle slow pulse on both lights
  if(volcanoLights){
    const flicker=0.7+Math.sin(elapsed*.8)*0.15+Math.sin(elapsed*2.3)*.08+Math.sin(elapsed*5.1)*.04;
    volcanoLights[0].intensity=200*flicker;
    volcanoLights[1].intensity=100*(0.8+Math.sin(elapsed*1.4+1)*.18);
    if(volcanoLights[2]) volcanoLights[2].intensity=60*(0.85+Math.sin(elapsed*.6+2)*.12);
  }

  // Koi â€” swerving river-like movement with S-curve body flex
  for(const k of koiFish){
    k.spdTimer+=delta;

    if(k.paused){
      k.pauseTimer+=delta;
      k.angle+=0.002*delta; // barely drift
      // Slow idle sway
      if(k.tailPivot) k.tailPivot.rotation.y=Math.sin(elapsed*0.9+k.wobble)*0.1;
      if(k.midPivot)  k.midPivot.rotation.y =Math.sin(elapsed*0.9+k.wobble)*0.04;
      if(k.pauseTimer>=k.pauseDur){
        k.paused=false; k.spdTimer=0;
        k.nextSpdChange=4+Math.random()*7;
        k.targetSpd=0.035+Math.random()*0.05;
      }
    } else {
      // Smooth speed ramp
      k.spd+=(k.targetSpd-k.spd)*Math.min(delta*0.5,1);
      k.angle+=k.spd*delta;

      if(k.spdTimer>=k.nextSpdChange){
        k.spdTimer=0;
        const roll=Math.random();
        if(roll<0.22){
          k.paused=true; k.pauseTimer=0;
          k.pauseDur=1.5+Math.random()*3.5;
          k.targetSpd=0;
        } else if(roll<0.5){
          k.targetSpd=0.02+Math.random()*0.03;
          k.nextSpdChange=5+Math.random()*8;
        } else {
          k.targetSpd=0.05+Math.random()*0.055;
          k.nextSpdChange=3+Math.random()*5;
        }
      }

      // River swerve: two overlapping sines at different freq/phase
      // gives an irregular S-path rather than a clean sine wave
      const sw1=Math.sin(elapsed*k.swerveFreq        +k.swervePhase        )*k.swerveAmp;
      const sw2=Math.sin(elapsed*k.swerveFreq*1.7    +k.swervePhase+1.3    )*(k.swerveAmp*0.4);
      const swerve=sw1+sw2;
      const r=k.orbitR+swerve;

      k.group.position.x=Math.cos(k.angle)*r;
      k.group.position.z=Math.sin(k.angle)*r;
      k.group.position.y=0.5+Math.sin(elapsed*0.35+k.wobble)*0.09;

      // True heading: tangent of actual world path
      // Next position estimate for forward diff
      const nextAngle=k.angle+k.spd*delta*2;
      const sw1n=Math.sin((elapsed+delta*2)*k.swerveFreq     +k.swervePhase    )*k.swerveAmp;
      const sw2n=Math.sin((elapsed+delta*2)*k.swerveFreq*1.7 +k.swervePhase+1.3)*(k.swerveAmp*0.4);
      const rn=k.orbitR+sw1n+sw2n;
      const nx=Math.cos(nextAngle)*rn, nz=Math.sin(nextAngle)*rn;
      const dx=nx-k.group.position.x, dz=nz-k.group.position.z;
      k.group.rotation.y=Math.atan2(-dx,-dz);

      // S-curve body flex driven by swerve derivative
      const sw1d=Math.cos(elapsed*k.swerveFreq+k.swervePhase)*k.swerveFreq*k.swerveAmp;
      const sw2d=Math.cos(elapsed*k.swerveFreq*1.7+k.swervePhase+1.3)*k.swerveFreq*1.7*(k.swerveAmp*0.4);
      const swerveRate=(sw1d+sw2d)*0.012; // normalise

      // Tail: wag + lean into swerve
      const wagFreq=2.5+k.spd*22;
      const wagAmp=0.15+Math.min(0.5,k.spd*6);
      const wag=Math.sin(elapsed*wagFreq+k.wobble)*wagAmp;
      if(k.tailPivot) k.tailPivot.rotation.y=wag - swerveRate*1.6;
      if(k.midPivot)  k.midPivot.rotation.y =(wag - swerveRate)*0.4;
    }
  }


  // Frog
  tickFrog(delta);
  tickCat(delta, elapsed);

  // Stars: twinkle â€” slowly modulate overall opacity around the base value
  if(currentNightness>.1){
    const base=Math.max(0,Math.min(1,currentNightness*1.6-0.1));
    starPoints.material.opacity=base*(0.82+Math.sin(elapsed*.7)*.07+Math.sin(elapsed*1.3+1.1)*.05);
  }

  // Shooting stars
  tickShootingStars(delta, elapsed, currentNightness);

  // Candle flicker â€” elapsed and currentNightness both available here
  for(let ci=0;ci<candleLights.length;ci++){
    const c=candleLights[ci];
    const flicker=0.82+Math.sin(elapsed*7.3+ci*2.1)*.1+Math.sin(elapsed*13.7+ci*1.3)*.06+Math.sin(elapsed*3.1+ci)*.04;
    c.light.intensity=currentNightness>0.05 ? c.base*flicker*Math.min(1,currentNightness*3) : 0;
  }
  // Firepit flicker â€” always on, more intense at night
  for(let fi=0;fi<firepitLights.length;fi++){
    const f=firepitLights[fi];
    const flicker=0.75+Math.sin(elapsed*9.1+fi*3.3)*.14+Math.sin(elapsed*5.7+fi*1.7)*.09+Math.sin(elapsed*18+fi)*.05;
    f.light.intensity=f.base*flicker*(0.55+currentNightness*.45);
  }

  // Birds
  tickBirds(delta,elapsed);

  // Ripples
  tickRipples(delta);

  // Sakura petals
  tickPetals(delta,elapsed);

  // Windchime sway
  tickWindchime(elapsed);

  // Weather (rain + mist)
  tickWeather(elapsed);

  // Trees: light pulse, task-age growth
  const now=Date.now();
  for(const task of tasks){
    const light=task.tree.children.find(c=>c.isLight);
    if(light){const cfg=priConfigs[task.priority||'med'];light.intensity=cfg.lightInt+Math.sin(elapsed*1.5+task.tree.position.x)*4;}

    // Task age growth: tree grows up to 30% larger over 24h
    const ageH=(now-task.date.getTime())/3600000;
    const growFactor=1+Math.min(ageH/24,.8)*.3;
    task.baseScale=(priConfigs[task.priority||'med'].treeScale)*growFactor;
    if(task.tree!==selectedTree) task.tree.scale.setScalar(task.baseScale);
  }

  // Desktop hover cursor â€” throttled to every 4 frames, cache tree list
  frameCount++;
  if(frameCount%4===0 && !isMobile() && tasks.length){
    raycaster.setFromCamera(pointer,camera);
    const treeMeshes=tasks.flatMap(t=>t.tree.children.filter(c=>c.isMesh));
    document.body.style.cursor=getTreeFromHits(raycaster.intersectObjects(treeMeshes,false))?'pointer':'default';
  }

  controls.update();
  renderer.render(scene,camera);
  if(tasks.length) labelRenderer.render(scene,camera);
}

// â”€â”€ Simple bench â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createFlowerPatch(cx, cz, count=40){
  const dummy=new THREE.Object3D();
  // Stem â€” thinner and shorter
  const stemGeo=new THREE.BoxGeometry(.07,.3,.07);
  const stemMat=new THREE.MeshStandardMaterial({color:'#4a8c30',roughness:.9});
  const stemMesh=new THREE.InstancedMesh(stemGeo,stemMat,count);
  stemMesh.receiveShadow=true;

  // Flower heads â€” smaller discs
  const flowerColors=['#f9a8d4','#fde68a','#c4b5fd','#f87171','#fbbf24','#a5f3fc','#fb923c'];
  const headGeo=new THREE.CylinderGeometry(.16,.14,.09,6);
  const headMeshes=flowerColors.map(c=>{
    const m=new THREE.InstancedMesh(headGeo,
      new THREE.MeshStandardMaterial({color:c,emissive:c,emissiveIntensity:.18,roughness:.75}),
      Math.ceil(count/flowerColors.length)+2);
    m.receiveShadow=true; return m;
  });
  const headCounts=new Array(flowerColors.length).fill(0);

  // Centre dot â€” tiny
  const centreGeo=new THREE.CylinderGeometry(.05,.05,.1,5);
  const centreMat=new THREE.MeshStandardMaterial({color:'#fef08a',emissive:'#fef08a',emissiveIntensity:.35});
  const centreMesh=new THREE.InstancedMesh(centreGeo,centreMat,count);

  let si=0;
  for(let attempt=0;attempt<count*6&&si<count;attempt++){
    const angle=Math.random()*Math.PI*2;
    // Wider spread radius with Poisson-ish spacing using sqrt for uniform distribution
    const r=Math.sqrt(Math.random())*14;
    const x=cx+Math.cos(angle)*r, z=cz+Math.sin(angle)*r;
    const y=getGroundHeight(x,z);
    if(y<2) continue;
    const h=.22+Math.random()*.22;
    // Stem
    dummy.position.set(x,y+h/2,z); dummy.scale.set(1,h*3,1);
    dummy.rotation.y=Math.random()*Math.PI; dummy.updateMatrix();
    stemMesh.setMatrixAt(si,dummy.matrix);
    // Head
    dummy.position.set(x,y+h+.05,z); dummy.scale.setScalar(.8+Math.random()*.35);
    dummy.updateMatrix();
    const ci=si%flowerColors.length;
    headMeshes[ci].setMatrixAt(headCounts[ci],dummy.matrix);
    headCounts[ci]++;
    // Centre dot
    dummy.position.set(x,y+h+.1,z); dummy.scale.setScalar(1);
    dummy.updateMatrix(); centreMesh.setMatrixAt(si,dummy.matrix);
    si++;
  }
  stemMesh.count=si; centreMesh.count=si;
  stemMesh.instanceMatrix.needsUpdate=true; centreMesh.instanceMatrix.needsUpdate=true;
  headMeshes.forEach((m,i)=>{ m.count=headCounts[i]; m.instanceMatrix.needsUpdate=true; scene.add(m); });
  scene.add(stemMesh,centreMesh);
}

function createCatCushion(x, z){
  const g=new THREE.Group();
  const y=getGroundHeight(x,z);
  // Base cushion â€” flat rounded box
  const cushion=new THREE.Mesh(
    new THREE.BoxGeometry(1.4,.28,1.1),
    new THREE.MeshStandardMaterial({color:'#c4a882',roughness:.85}) // warm linen
  );
  cushion.position.y=.14;
  // Soft top pad â€” slightly smaller, lighter
  const pad=new THREE.Mesh(
    new THREE.BoxGeometry(1.2,.12,.95),
    new THREE.MeshStandardMaterial({color:'#e8d8c0',roughness:.9})
  );
  pad.position.y=.32;
  // Border trim â€” thin strips around edge for that pillow look
  [['#b8926a',1.45,.08,1.1],['#b8926a',1.4,.08,1.15]].forEach(([col,w,h,d],i)=>{
    const trim=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),
      new THREE.MeshStandardMaterial({color:col,roughness:.9}));
    trim.position.y=.22+i*.04; g.add(trim);
  });
  // Small indentation hint â€” dark oval pressed into pad centre
  const indent=new THREE.Mesh(
    new THREE.BoxGeometry(.55,.04,.42),
    new THREE.MeshStandardMaterial({color:'#d4c4aa',roughness:.95})
  );
  indent.position.y=.39;
  g.add(cushion,pad,indent);
  g.position.set(x,y,z);
  g.rotation.y=Math.random()*Math.PI;
  g.traverse(c=>{if(c.isMesh){c.receiveShadow=true;c.castShadow=true;}});
  scene.add(g);
}

function createBench(position, rotY=0){
  const g=new THREE.Group();
  const wood=new THREE.MeshStandardMaterial({color:'#6b4226',roughness:.88});
  const stone=new THREE.MeshStandardMaterial({color:'#7a7570',roughness:.95});
  // Seat plank
  const seat=new THREE.Mesh(new THREE.BoxGeometry(2.2,.15,.7),wood); seat.position.y=.72;
  // Two stone legs
  [-0.8,0.8].forEach(lx=>{
    const leg=new THREE.Mesh(new THREE.BoxGeometry(.28,.7,.55),stone); leg.position.set(lx,.35,0); g.add(leg);
  });
  // Back rest
  const back=new THREE.Mesh(new THREE.BoxGeometry(2.2,.6,.1),wood); back.position.set(0,1.12,.3); back.rotation.x=-.1;
  g.add(seat,back);
  g.rotation.y=rotY; g.position.copy(position);
  g.traverse(c=>{if(c.isMesh){c.castShadow=c.receiveShadow=true;}}); scene.add(g);
}

// Sample min terrain height across a footprint â€” building sits on the lowest corner so it never floats
function getMinGroundHeight(cx,cz,halfW,halfD,step=1){
  let minH=9999;
  for(let x=cx-halfW;x<=cx+halfW;x+=step)
    for(let z=cz-halfD;z<=cz+halfD;z+=step)
      minH=Math.min(minH,getGroundHeight(x,z));
  return minH===9999?0:minH;
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â”€â”€ Sakura petal particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const petalSystems=[];

function createPetalSystem(cx,cz,count=55){
  const mat=new THREE.MeshStandardMaterial({
    color:'#f9b8cc',emissive:'#e8809a',emissiveIntensity:.3,
    roughness:.9,side:THREE.DoubleSide,transparent:true,opacity:.88
  });
  const geo=new THREE.PlaneGeometry(.18,.12);
  const mesh=new THREE.InstancedMesh(geo,mat,count);
  mesh.castShadow=false;
  scene.add(mesh);
  const petals=[];
  const baseY=getGroundHeight(cx,cz)+4;
  for(let i=0;i<count;i++){
    petals.push({
      x:cx+(Math.random()-.5)*8, y:baseY+Math.random()*5, z:cz+(Math.random()-.5)*8,
      vy:-(0.4+Math.random()*.5),       // fall speed
      vx:(Math.random()-.5)*.25,        // lazy drift
      vz:(Math.random()-.5)*.25,
      spin:Math.random()*Math.PI*2,
      spinRate:(Math.random()-.5)*.04,
      wobble:Math.random()*Math.PI*2,
      wobbleSpeed:.8+Math.random()*.6,
      resetY:baseY+5+Math.random()*4,
      phase:Math.random()*Math.PI*2,
    });
  }
  petalSystems.push({mesh,petals,cx,cz,baseY});
}

function tickPetals(delta,elapsed){
  const dummy=new THREE.Object3D();
  for(const sys of petalSystems){
    for(let i=0;i<sys.petals.length;i++){
      const p=sys.petals[i];
      // Gentle horizontal sway â€” like real petals
      const sway=Math.sin(elapsed*p.wobbleSpeed+p.wobble)*.012;
      p.x+=p.vx*delta+sway;
      p.z+=p.vz*delta+sway*.7;
      p.y+=p.vy*delta;
      p.spin+=p.spinRate;
      // Reset when below ground â€” respawn at canopy height with new spread
      if(p.y<getGroundHeight(p.x,p.z)+.2){
        p.x=sys.cx+(Math.random()-.5)*8;
        p.z=sys.cz+(Math.random()-.5)*8;
        p.y=sys.baseY+Math.random()*4;
      }
      dummy.position.set(p.x,p.y,p.z);
      dummy.rotation.set(
        Math.sin(elapsed*p.wobbleSpeed+p.phase)*.5,
        p.spin,
        Math.cos(elapsed*p.wobbleSpeed*.7+p.phase)*.4
      );
      dummy.updateMatrix();
      sys.mesh.setMatrixAt(i,dummy.matrix);
    }
    sys.mesh.instanceMatrix.needsUpdate=true;
  }
}

// â”€â”€ Kitsune fox statue â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createKitsune(x,z,rotY=0){
  const y=getGroundHeight(x,z);
  const g=new THREE.Group();
  const stone=new THREE.MeshStandardMaterial({color:'#9a9488',roughness:.97,metalness:.02});
  const stoneDark=new THREE.MeshStandardMaterial({color:'#7a7068',roughness:.98});
  const accent=new THREE.MeshStandardMaterial({color:'#cc2200',emissive:'#880000',emissiveIntensity:.15,roughness:.85}); // red bib

  // Pedestal
  const ped=new THREE.Mesh(new THREE.BoxGeometry(.42,.28,.38),stoneDark);
  ped.position.y=.14; g.add(ped);
  const pedTop=new THREE.Mesh(new THREE.BoxGeometry(.48,.08,.44),stone);
  pedTop.position.y=.3; g.add(pedTop);

  // Body â€” tapered sitting form
  const body=new THREE.Mesh(new THREE.CylinderGeometry(.14,.18,.38,8),stone);
  body.position.y=.59; g.add(body);

  // Chest / bib â€” red cloth panel
  const bib=new THREE.Mesh(new THREE.BoxGeometry(.18,.22,.04),accent);
  bib.position.set(0,.58,.13); g.add(bib);

  // Neck
  const neck=new THREE.Mesh(new THREE.CylinderGeometry(.1,.12,.14,7),stone);
  neck.position.y=.87; g.add(neck);

  // Head â€” slightly elongated sphere
  const head=new THREE.Mesh(new THREE.SphereGeometry(.14,8,7),stone);
  head.scale.set(1,1.1,1.05); head.position.y=1.05; g.add(head);

  // Snout
  const snout=new THREE.Mesh(new THREE.BoxGeometry(.1,.07,.14),stone);
  snout.position.set(0,1.02,.14); g.add(snout);

  // Ears â€” two pointy wedges
  [-.09,.09].forEach(ex=>{
    const ear=new THREE.Mesh(new THREE.ConeGeometry(.055,.16,5),stone);
    ear.position.set(ex,1.19,.02);
    ear.rotation.z=ex>0?.18:-.18; g.add(ear);
  });

  // Eyes â€” tiny dark spheres
  [-.06,.06].forEach(ex=>{
    const eye=new THREE.Mesh(new THREE.SphereGeometry(.025,5,5),stoneDark);
    eye.position.set(ex,1.06,.13); g.add(eye);
  });

  // Tail â€” swept curve up behind
  const tail=new THREE.Mesh(new THREE.TorusGeometry(.22,.045,5,10,Math.PI*.8),stone);
  tail.rotation.x=Math.PI*.55; tail.position.set(.02,.62,-.18); g.add(tail);

  g.position.set(x,y,z);
  g.rotation.y=rotY;
  g.traverse(c=>{if(c.isMesh){c.castShadow=c.receiveShadow=true;}});
  scene.add(g);
}

// â”€â”€ Stepping-stone bridge over a low water indent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createSteppingStoneBridge(x1,z1,x2,z2){
  // Lay chunky flat stones at ground level crossing from (x1,z1) to (x2,z2)
  const stoneMat=new THREE.MeshStandardMaterial({color:'#8a8278',roughness:.97});
  const mossMat =new THREE.MeshStandardMaterial({color:'#5a7840',roughness:.96});
  const dx=x2-x1,dz=z2-z1,dist=Math.sqrt(dx*dx+dz*dz);
  const steps=Math.max(3,Math.round(dist/1.2));
  const dummy=new THREE.Object3D();
  for(let i=0;i<=steps;i++){
    const t=i/steps;
    const sx=x1+dx*t+(Math.random()-.5)*.22;
    const sz=z1+dz*t+(Math.random()-.5)*.22;
    const sy=1.58; // sit on water surface
    const sc=.72+Math.random()*.36;
    const angle=Math.atan2(dx,dz)+(Math.random()-.5)*.35;
    const stone=new THREE.Mesh(new THREE.CylinderGeometry(.42,.5,.13,7),i%4===0?mossMat:stoneMat);
    stone.position.set(sx,sy,sz);
    stone.rotation.y=angle;
    stone.scale.set(sc,1,sc);
    stone.castShadow=stone.receiveShadow=true;
    scene.add(stone);
  }
}

// â”€â”€ Windchime â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let windchimeData=null;
function createWindchime(x,z,height=5.2){
  const y=getGroundHeight(x,z);
  const g=new THREE.Group();
  const metalMat=new THREE.MeshStandardMaterial({color:'#c8c0a8',emissive:'#b0a888',emissiveIntensity:.15,roughness:.35,metalness:.8});
  const woodMat =new THREE.MeshStandardMaterial({color:'#7a5c30',roughness:.9});
  const cordMat =new THREE.MeshStandardMaterial({color:'#d4c090',roughness:.95});

  // Hanging beam
  const beam=new THREE.Mesh(new THREE.CylinderGeometry(.025,.025,.7,6),woodMat);
  beam.rotation.z=Math.PI/2; beam.position.y=height; g.add(beam);

  // Central disc / windplate
  const disc=new THREE.Mesh(new THREE.CylinderGeometry(.12,.12,.025,10),metalMat);
  disc.position.y=height-.55; g.add(disc);

  // Chime tubes â€” 5 tubes of varying length hanging from disc
  const tubes=[];
  const lengths=[.55,.45,.65,.4,.58];
  const offsets=[-.24,-.12,0,.12,.24];
  for(let i=0;i<5;i++){
    const cord=new THREE.Mesh(new THREE.CylinderGeometry(.008,.008,.5,4),cordMat);
    cord.position.set(offsets[i],height-.8-.25,0); g.add(cord);
    const tube=new THREE.Mesh(new THREE.CylinderGeometry(.022,.022,lengths[i],6),metalMat);
    tube.position.set(offsets[i],height-.8-.5-lengths[i]/2,0);
    g.add(tube);
    tubes.push({tube,base:tube.position.clone(),phase:i*1.3,amp:.018+i*.008,spd:.9+i*.15});
  }

  // Mount rope to hang from above
  const rope=new THREE.Mesh(new THREE.CylinderGeometry(.012,.012,.5,4),cordMat);
  rope.position.y=height+.25; g.add(rope);

  g.position.set(x,y,z);
  g.traverse(c=>{if(c.isMesh){c.castShadow=true;}});
  scene.add(g);
  windchimeData={g,tubes};
}

function tickWindchime(elapsed){
  if(!windchimeData)return;
  const {g,tubes}=windchimeData;
  // Gentle collective sway
  const masterSway=Math.sin(elapsed*.4)*.012+Math.sin(elapsed*.9+.5)*.007;
  g.rotation.z=masterSway;
  // Each tube sways independently â€” slightly different phase/speed
  for(const t of tubes){
    t.tube.rotation.z=Math.sin(elapsed*t.spd+t.phase)*t.amp+masterSway*.4;
  }
}

// â”€â”€ Weather: rain + morning mist â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let rainSystem=null,mistMesh=null,rainAudioNode=null,rainGainNode=null;

function initWeather(){
  // â”€â”€ Rain particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const DROPS=1200;
  const rainGeo=new THREE.BufferGeometry();
  const pos=new Float32Array(DROPS*3),vel=new Float32Array(DROPS);
  for(let i=0;i<DROPS;i++){
    pos[i*3  ]=( Math.random()-.5)*80;
    pos[i*3+1]=Math.random()*30+5;
    pos[i*3+2]=(Math.random()-.5)*80;
    vel[i]=8+Math.random()*6;
  }
  rainGeo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  const rainMat=new THREE.PointsMaterial({color:'#aaccee',size:.12,transparent:true,opacity:0,depthWrite:false,sizeAttenuation:true});
  const rain=new THREE.Points(rainGeo,rainMat);
  scene.add(rain);
  rainSystem={rain,pos,vel,DROPS};

  // â”€â”€ Mist plane â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const mistMat=new THREE.MeshStandardMaterial({color:'#ddeeff',transparent:true,opacity:0,depthWrite:false,side:THREE.DoubleSide,roughness:1,metalness:0});
  mistMesh=new THREE.Mesh(new THREE.PlaneGeometry(120,120),mistMat);
  mistMesh.rotation.x=-Math.PI/2;
  mistMesh.position.y=3.5;
  scene.add(mistMesh);

  // â”€â”€ Rain audio â€” synthesised drizzle via Web Audio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Created lazily when audio context exists
}

function buildRainAudio(){
  if(!audioCtx||rainAudioNode)return;
  const sr=audioCtx.sampleRate,sec=3,size=sr*sec;
  const buf=audioCtx.createBuffer(1,size,sr);
  const d=buf.getChannelData(0);
  for(let i=0;i<size;i++) d[i]=(Math.random()*2-1)*(Math.random()>.992?1:.08);
  rainAudioNode=audioCtx.createBufferSource();
  rainAudioNode.buffer=buf; rainAudioNode.loop=true;
  const lp=audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=2200;
  const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=400;
  rainGainNode=audioCtx.createGain(); rainGainNode.gain.value=0;
  rainAudioNode.connect(lp); lp.connect(hp); hp.connect(rainGainNode);
  if(_masterGain) rainGainNode.connect(_masterGain);
  else rainGainNode.connect(audioCtx.destination);
  rainAudioNode.start();
}

function tickWeather(elapsed){
  if(!rainSystem)return;
  const now=new Date();
  const hour=now.getHours()+now.getMinutes()/60;

  // Rain: active at night (21:00â€“06:00)
  const isRaining=hour>=21||hour<6;
  const rainTarget=isRaining?0.78:0;
  const curRainOp=rainSystem.rain.material.opacity;
  rainSystem.rain.material.opacity+=(rainTarget-curRainOp)*.008;
  rainSystem.rain.material.opacity=Math.max(0,Math.min(1,rainSystem.rain.material.opacity));

  if(rainSystem.rain.material.opacity>.02){
    const pos=rainSystem.pos;
    for(let i=0;i<rainSystem.DROPS;i++){
      pos[i*3+1]-=rainSystem.vel[i]*.016;
      pos[i*3  ]+=.04; // slight wind drift
      if(pos[i*3+1]<0){
        pos[i*3  ]=(Math.random()-.5)*80;
        pos[i*3+1]=28+Math.random()*8;
        pos[i*3+2]=(Math.random()-.5)*80;
      }
    }
    rainSystem.rain.geometry.attributes.position.needsUpdate=true;
  }

  // Rain audio fade
  if(audioCtx&&!rainAudioNode) buildRainAudio();
  if(rainGainNode){
    const targetVol=isRaining&&soundOn?.14:0;
    rainGainNode.gain.setTargetAtTime(targetVol,audioCtx.currentTime,.8);
  }

  // Mist: morning 05:30â€“09:00, fades out by 9am
  const mistStart=5.5,mistPeak=6.5,mistEnd=9.0;
  let mistTarget=0;
  if(hour>=mistStart&&hour<mistPeak) mistTarget=(hour-mistStart)/(mistPeak-mistStart)*0.22;
  else if(hour>=mistPeak&&hour<mistEnd) mistTarget=(1-(hour-mistPeak)/(mistEnd-mistPeak))*0.22;
  mistMesh.material.opacity+=(mistTarget-mistMesh.material.opacity)*.004;
}

// â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
createWorld();
createBeach();
// Structures
// Second shrine â€” mid-level south-east slope. Use min footprint height so it sits INTO terrain, never above it.
{ const sx=18,sz=-16;
  createStoneShrine(new THREE.Vector3(sx, getMinGroundHeight(sx,sz,2.5,2)-0.15, sz));
}
createStoneShrine(new THREE.Vector3(-18, getMinGroundHeight(-18,14,2.5,2)-0.15, 14));

// Lamp posts â€” spread across the island at compass-ish positions
createLampPost(new THREE.Vector3(28,getGroundHeight(28,2),2));      // east
createLampPost(new THREE.Vector3(-24,getGroundHeight(-24,-6),-6));  // west
createLampPost(new THREE.Vector3(4,getGroundHeight(4,-28),-28));    // south
createLampPost(new THREE.Vector3(-6,getGroundHeight(-6,26),26));    // north

// Peak torii + bench â€” x=3,z=0 is the mathematical terrain peak (sin/cos formula + distance falloff)
{ const peakX=3, peakZ=0;
  createToriiGate(new THREE.Vector3(peakX,0,peakZ),0);
  const benchX=peakX+1.5, benchZ=peakZ+3;
  createBench(new THREE.Vector3(benchX, getGroundHeight(benchX, benchZ), benchZ), Math.PI);
}
// Shore torii â€” east beach approach, facing inland
createToriiGate(new THREE.Vector3(26,0,24),Math.PI*1.25);

createOvalPath();



// Lily pads in ocean
createOceanLilyPads();
// Bamboo groves â€” avoid beach side
createBambooGrove(-18,8,30); createBambooGrove(14,18,22);
createBambooGrove(-28,4,18); createBambooGrove(24,-8,14);
// â”€â”€ Stone Well â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createWell(x, z){
  const y=getGroundHeight(x,z);
  const g=new THREE.Group();
  const stone=new THREE.MeshStandardMaterial({color:'#7a7068',roughness:.95});
  const stoneDark=new THREE.MeshStandardMaterial({color:'#5a524a',roughness:.97});
  const wood=new THREE.MeshStandardMaterial({color:'#6b4a2a',roughness:.9});
  const rope=new THREE.MeshStandardMaterial({color:'#b8955a',roughness:.95});
  const water=new THREE.MeshStandardMaterial({color:'#4a90b8',emissive:'#1a5a88',emissiveIntensity:.4,roughness:.1,metalness:.2});

  // Base ring of stones â€” 8 chunky blocks arranged in circle
  for(let i=0;i<8;i++){
    const a=(i/8)*Math.PI*2;
    const bx=Math.cos(a)*.72, bz=Math.sin(a)*.72;
    const b=new THREE.Mesh(new THREE.BoxGeometry(.42,.55,.38), i%2===0?stone:stoneDark);
    b.position.set(bx,.27,bz); b.rotation.y=a; g.add(b);
  }
  // Mortar fill â€” short cylinder inside ring
  const inner=new THREE.Mesh(new THREE.CylinderGeometry(.52,.52,.5,12),stoneDark);
  inner.position.y=.25; g.add(inner);
  // Water surface inside well
  const ws=new THREE.Mesh(new THREE.CircleGeometry(.48,12),water);
  ws.rotation.x=-Math.PI/2; ws.position.y=.52; g.add(ws);
  // Cap ring â€” slightly wider stones on top
  for(let i=0;i<8;i++){
    const a=((i+.5)/8)*Math.PI*2;
    const b=new THREE.Mesh(new THREE.BoxGeometry(.46,.28,.42),stone);
    b.position.set(Math.cos(a)*.74,.65,Math.sin(a)*.74); b.rotation.y=a; g.add(b);
  }
  // Two wooden posts
  [-1,1].forEach(s=>{
    const post=new THREE.Mesh(new THREE.CylinderGeometry(.09,.11,2.2,6),wood);
    post.position.set(s*.62,.9+1.1,0); g.add(post);
    // Notch at top
    const notch=new THREE.Mesh(new THREE.BoxGeometry(.2,.18,.28),stoneDark);
    notch.position.set(s*.62,2.1,0); g.add(notch);
  });
  // Crossbeam
  const beam=new THREE.Mesh(new THREE.CylinderGeometry(.07,.07,1.4,6),wood);
  beam.rotation.z=Math.PI/2; beam.position.y=2.1; g.add(beam);
  // Bucket hanging from rope
  const ropeM=new THREE.Mesh(new THREE.CylinderGeometry(.02,.02,.55,4),rope);
  ropeM.position.set(.15,1.82,0); g.add(ropeM);
  const bucket=new THREE.Mesh(new THREE.CylinderGeometry(.14,.1,.28,7),wood);
  bucket.position.set(.15,1.44,0); g.add(bucket);
  const bucketRim=new THREE.Mesh(new THREE.TorusGeometry(.14,.025,5,10),stoneDark);
  bucketRim.position.set(.15,1.58,0); bucketRim.rotation.x=Math.PI/2; g.add(bucketRim);

  g.position.set(x,y,z);
  g.traverse(c=>{if(c.isMesh){c.castShadow=c.receiveShadow=true;}});
  scene.add(g);
}

// â”€â”€ Firepit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const firepitLights=[];
function createFirepit(x,z){
  const y=getGroundHeight(x,z);
  const g=new THREE.Group();
  const stone=new THREE.MeshStandardMaterial({color:'#6a6058',roughness:.97});
  const soot =new THREE.MeshStandardMaterial({color:'#1a1510',roughness:1});
  const wood =new THREE.MeshStandardMaterial({color:'#5a3518',roughness:.95});
  const charMat=new THREE.MeshStandardMaterial({color:'#ff5500',emissive:'#ff2200',emissiveIntensity:3,roughness:1});
  const flameMat=new THREE.MeshStandardMaterial({color:'#ffaa00',emissive:'#ff6600',emissiveIntensity:5,transparent:true,opacity:.88});
  const flameMat2=new THREE.MeshStandardMaterial({color:'#ffdd44',emissive:'#ffaa00',emissiveIntensity:6,transparent:true,opacity:.7});

  // Stone ring â€” 8 rocks
  for(let i=0;i<8;i++){
    const a=(i/8)*Math.PI*2;
    const r=new THREE.Mesh(new THREE.BoxGeometry(.32+Math.random()*.12,.22+Math.random()*.1,.28+Math.random()*.1),stone);
    r.position.set(Math.cos(a)*.65,y+.11,Math.sin(a)*.65);
    r.rotation.y=a+Math.random()*.5;
    r.castShadow=r.receiveShadow=true; g.add(r);
  }
  // Ash pit inside
  const ash=new THREE.Mesh(new THREE.CylinderGeometry(.48,.52,.06,10),soot);
  ash.position.y=y+.03; ash.receiveShadow=true; g.add(ash);
  // Crossed logs
  [[.35,-.25,Math.PI*.1],[-.3,.28,Math.PI*.55],[.15,.32,-Math.PI*.2]].forEach(([lx,lz,ry])=>{
    const log=new THREE.Mesh(new THREE.CylinderGeometry(.065,.08,.9,6),wood);
    log.rotation.set(Math.PI/2,ry,0); log.position.set(lx,y+.14,lz);
    log.castShadow=true; g.add(log);
  });
  // Glowing embers â€” flat discs
  for(let i=0;i<6;i++){
    const a=Math.random()*Math.PI*2,r=Math.random()*.3;
    const ember=new THREE.Mesh(new THREE.CylinderGeometry(.05,.07,.04,5),charMat);
    ember.position.set(Math.cos(a)*r,y+.16,Math.sin(a)*r); g.add(ember);
  }
  // Flame â€” two overlapping cones for inner/outer
  const flameInner=new THREE.Mesh(new THREE.ConeGeometry(.18,.55,6),flameMat2);
  flameInner.position.y=y+.52; g.add(flameInner);
  const flameOuter=new THREE.Mesh(new THREE.ConeGeometry(.28,.38,7),flameMat);
  flameOuter.position.y=y+.38; g.add(flameOuter);
  // Warm point light
  const light=new THREE.PointLight(0xff6600,120,18); light.position.y=y+.7;
  firepitLights.push({light,base:120});
  g.add(light);
  scene.add(g);
}

// â”€â”€ Wooden Dock & Rowboat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createDock(x,z,angle=0){
  const y=getGroundHeight(x,z);
  const g=new THREE.Group();
  const plankMat=new THREE.MeshStandardMaterial({color:'#7a5c3a',roughness:.95});
  const postMat =new THREE.MeshStandardMaterial({color:'#5a3c20',roughness:.98});
  const boatMat =new THREE.MeshStandardMaterial({color:'#6b4a28',roughness:.92});
  const ropeM   =new THREE.MeshStandardMaterial({color:'#c8a870',roughness:.95});

  const PLANKS=7, PLANK_W=.9, PLANK_GAP=.08;
  // Dock boards extending outward
  for(let i=0;i<PLANKS;i++){
    const p=new THREE.Mesh(new THREE.BoxGeometry(PLANK_W,.1,1.0),plankMat);
    p.position.set(0,.05,i*(1.0+PLANK_GAP));
    p.castShadow=p.receiveShadow=true; g.add(p);
  }
  // Cross brace every 2 planks
  for(let i=0;i<3;i++){
    const b=new THREE.Mesh(new THREE.BoxGeometry(PLANK_W+.2,.08,.16),plankMat);
    b.position.set(0,.02,i*2.2+.5); g.add(b);
  }
  // Piles going down into water
  [0,PLANKS-1].forEach(pi=>{
    [-1,1].forEach(side=>{
      const pile=new THREE.Mesh(new THREE.CylinderGeometry(.07,.09,2.2,6),postMat);
      pile.position.set(side*.38,-1.05,pi*(1.0+PLANK_GAP)+.5);
      pile.castShadow=true; g.add(pile);
      // Mooring ring
      const ring=new THREE.Mesh(new THREE.TorusGeometry(.07,.018,5,8),postMat);
      ring.position.set(side*.38,.25,pi*(1.0+PLANK_GAP)+.5);
      ring.rotation.x=Math.PI/2; g.add(ring);
    });
  });

  // Rowboat tied to end of dock
  const bx=0, bz=(PLANKS+1.5)*(1.0+PLANK_GAP);
  const hull=new THREE.Mesh(new THREE.BoxGeometry(1.1,.38,2.2),boatMat); hull.position.set(bx,.12,bz); g.add(hull);
  // Hull shaping â€” taper front & back with smaller boxes
  [[0,.08,bz+.9,.65,.22,.5],[0,.08,bz-.9,.65,.22,.5]].forEach(([px,py,pz,sw,sh,sd])=>{
    const s=new THREE.Mesh(new THREE.BoxGeometry(sw,sh,sd),boatMat); s.position.set(px,py,pz); g.add(s);
  });
  // Seats
  [bz-.5,bz+.5].forEach(sz=>{
    const seat=new THREE.Mesh(new THREE.BoxGeometry(.85,.08,.24),plankMat);
    seat.position.set(bx,.32,sz); g.add(seat);
  });
  // Oars resting in boat
  [-1,1].forEach(side=>{
    const oar=new THREE.Mesh(new THREE.CylinderGeometry(.03,.04,1.8,5),plankMat);
    oar.rotation.set(0,side*.3,Math.PI*.1*side);
    oar.position.set(side*.3,.4,bz); g.add(oar);
  });
  // Rope from boat to dock
  const rope=new THREE.Mesh(new THREE.CylinderGeometry(.015,.015,.7,4),ropeM);
  rope.rotation.x=Math.PI*.1; rope.position.set(.4,.2,bz-1.1); g.add(rope);

  g.rotation.y=angle;
  g.position.set(x,y,z);
  g.traverse(c=>{if(c.isMesh){c.castShadow=c.receiveShadow=true;}});
  scene.add(g);
}

// â”€â”€ Hanging lantern string â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createLanternString(ax,az,bx,bz,count=5,height=7){
  const postMat=new THREE.MeshStandardMaterial({color:'#2a2218',roughness:.8,metalness:.4});
  const cordMat=new THREE.MeshStandardMaterial({color:'#2a1e08',roughness:.9});
  const lanternMat=new THREE.MeshStandardMaterial({color:'#cc1100',roughness:.65,emissive:'#440000',emissiveIntensity:.4});
  const glowMat=new THREE.MeshStandardMaterial({color:'#fff8d0',emissive:'#ffcc44',emissiveIntensity:8,transparent:true,opacity:.95});

  const ay=getGroundHeight(ax,az)+height;
  const by=getGroundHeight(bx,bz)+height;

  for(let i=0;i<=count;i++){
    const t=i/count;
    const lx=ax+(bx-ax)*t, lz=az+(bz-az)*t;
    const sag=Math.sin(t*Math.PI)*2.8;
    const ly=ay+(by-ay)*t-sag;
    const gy=getGroundHeight(lx,lz);

    if(i===0||i===count){
      const postH=Math.max(1.5, ly-gy+.2);
      const post=new THREE.Mesh(new THREE.CylinderGeometry(.12,.15,postH,8),postMat);
      post.position.set(lx,gy+postH/2,lz);
      post.castShadow=true; scene.add(post);
      // Crossbar
      const bar=new THREE.Mesh(new THREE.CylinderGeometry(.05,.05,.9,6),postMat);
      bar.rotation.z=Math.PI/2; bar.position.set(lx,ly-.1,lz); scene.add(bar);
    }

    if(i>0&&i<count){
      const cord=new THREE.Mesh(new THREE.CylinderGeometry(.02,.02,.5,4),cordMat);
      cord.position.set(lx,ly-.25,lz); scene.add(cord);

      const lantern=new THREE.Group();
      // Body â€” big barrel lantern
      const body=new THREE.Mesh(new THREE.CylinderGeometry(.38,.38,.9,10),lanternMat);
      // Tapered top and bottom caps
      const topCap=new THREE.Mesh(new THREE.CylinderGeometry(.22,.38,.18,10),postMat);
      topCap.position.y=.54;
      const botCap=new THREE.Mesh(new THREE.CylinderGeometry(.38,.22,.18,10),postMat);
      botCap.position.y=-.54;
      // Tassel hanging below
      const tassel=new THREE.Mesh(new THREE.CylinderGeometry(.03,.01,.4,5),lanternMat);
      tassel.position.y=-.82;
      const glow=new THREE.Mesh(new THREE.SphereGeometry(.26,7,7),glowMat);
      const pt=new THREE.PointLight(0xffaa22,0,14);
      candleLights.push({light:pt,base:35});
      lantern.add(body,topCap,botCap,tassel,glow,pt);
      lantern.position.set(lx,ly-.95,lz);
      lantern.traverse(c=>{if(c.isMesh){c.castShadow=true;}});
      scene.add(lantern);
    }
  }
}

// â”€â”€ Moss-covered ruins â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createRuins(cx,cz,count=4){
  const stone=new THREE.MeshStandardMaterial({color:'#5a5850',roughness:.98});
  const mossMat=new THREE.MeshStandardMaterial({color:'#3a6030',roughness:.97});
  const rng=new THREE.Object3D();
  for(let i=0;i<count;i++){
    const a=Math.random()*Math.PI*2, r=2+Math.random()*5;
    const rx=cx+Math.cos(a)*r, rz=cz+Math.sin(a)*r;
    const ry=getGroundHeight(rx,rz);
    const g=new THREE.Group();
    const h=1.2+Math.random()*2.5; // broken column height
    // Main column shaft â€” cracked appearance via slight non-uniform scale
    const col=new THREE.Mesh(new THREE.CylinderGeometry(.28,.32,h,7),stone);
    col.scale.set(.9+Math.random()*.2,1,.85+Math.random()*.2);
    col.rotation.y=Math.random()*Math.PI;
    col.position.y=h/2; g.add(col);
    // Broken top â€” tilted cap piece
    const cap=new THREE.Mesh(new THREE.BoxGeometry(.72,.24,.72),stone);
    cap.position.y=h+.12; cap.rotation.set((Math.random()-.5)*.5,Math.random()*Math.PI,(Math.random()-.5)*.4);
    g.add(cap);
    // Moss patches on top and sides
    [[0,h+.22,0,.65,.08,.65],[.2,h*.5,.28,.3,.3,.08],[-.22,h*.6,-.2,.08,.28,.3]].forEach(([mx,my,mz,mw,mh,md])=>{
      const moss=new THREE.Mesh(new THREE.BoxGeometry(mw,mh,md),mossMat);
      moss.position.set(mx,my,mz); g.add(moss);
    });
    // Rubble â€” 2-3 scattered stone chunks nearby
    for(let j=0;j<2+Math.floor(Math.random()*2);j++){
      const ja=Math.random()*Math.PI*2, jr=.6+Math.random()*1.4;
      const chunk=new THREE.Mesh(new THREE.BoxGeometry(.25+Math.random()*.3,.18+Math.random()*.2,.22+Math.random()*.25),stone);
      chunk.position.set(Math.cos(ja)*jr,.1,Math.sin(ja)*jr);
      chunk.rotation.set(Math.random()*.4,Math.random()*Math.PI,Math.random()*.4); g.add(chunk);
    }
    g.position.set(rx,ry,rz);
    g.rotation.y=Math.random()*Math.PI*2;
    g.traverse(c=>{if(c.isMesh){c.castShadow=c.receiveShadow=true;}});
    scene.add(g);
  }
}


const candleLights=[]; // {light, base} for night flicker

function createCandle(x, y, z, scale=1){
  const g=new THREE.Group();
  const wax=new THREE.MeshStandardMaterial({color:'#f0e8cc',roughness:.9});
  const wickMat=new THREE.MeshStandardMaterial({color:'#1a1208',roughness:1});
  const flameMat=new THREE.MeshStandardMaterial({color:'#ffcc44',emissive:'#ff8800',emissiveIntensity:4,transparent:true,opacity:.92});

  const body=new THREE.Mesh(new THREE.CylinderGeometry(.1*scale,.12*scale,.45*scale,7),wax);
  body.position.y=.22*scale; g.add(body);
  const wick=new THREE.Mesh(new THREE.CylinderGeometry(.012,.012,.08*scale,4),wickMat);
  wick.position.y=.49*scale; g.add(wick);
  const flame=new THREE.Mesh(new THREE.SphereGeometry(.07*scale,5,5),flameMat);
  flame.scale.y=1.6; flame.position.y=.62*scale; g.add(flame);
  // Small halo
  const halo=new THREE.Mesh(new THREE.SphereGeometry(.22*scale,6,6),
    new THREE.MeshStandardMaterial({color:'#ffee88',emissive:'#ffaa22',emissiveIntensity:.8,transparent:true,opacity:.06,depthWrite:false,side:THREE.BackSide}));
  halo.position.y=.62*scale; g.add(halo);
  // Point light â€” warm, short range
  const light=new THREE.PointLight(0xff9922,0,8*scale); // starts at 0, night brings it up
  light.position.y=.65*scale; g.add(light);
  candleLights.push({light, base:18*scale});

  g.position.set(x,y,z);
  g.traverse(c=>{if(c.isMesh)c.castShadow=true;});
  scene.add(g);
}

function placeCandleGroup(cx, cz, count=3, spread=1.4){
  for(let i=0;i<count;i++){
    const a=(i/count)*Math.PI*2+Math.random()*.4;
    const r=Math.random()*spread;
    const wx=cx+Math.cos(a)*r, wz=cz+Math.sin(a)*r;
    const wy=getGroundHeight(wx,wz);
    const s=0.7+Math.random()*.6; // varied heights
    createCandle(wx,wy,wz,s);
  }
}

// â”€â”€ Sand Banks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createSandBanks(){
  const sandMat=new THREE.MeshStandardMaterial({color:'#c8ad7a',roughness:.98});
  const sandDarkMat=new THREE.MeshStandardMaterial({color:'#b89c68',roughness:.98});
  const grassMat=new THREE.MeshStandardMaterial({color:'#5a8a3a',roughness:.9,side:THREE.DoubleSide});
  const boxGeo=new THREE.BoxGeometry(1,0.18,1);
  const dummy=new THREE.Object3D();
  const sandCells=[];

  for(const [key,h] of terrain){
    const [x,z]=key.split(',').map(Number);
    if(h<=1) sandCells.push({x,z});
  }

  if(!sandCells.length) return;

  // Sand tiles
  const sandMesh=new THREE.InstancedMesh(boxGeo,sandMat,sandCells.length);
  const sandDarkMesh=new THREE.InstancedMesh(boxGeo,sandDarkMat,sandCells.length);
  sandMesh.receiveShadow=sandDarkMesh.receiveShadow=true;
  let si=0,di=0;
  for(const {x,z} of sandCells){
    const useLight=Math.random()>.35;
    dummy.position.set(x,1.54,z);
    dummy.rotation.y=Math.random()*Math.PI*.5;
    dummy.scale.set(.98+Math.random()*.04,1,.98+Math.random()*.04);
    dummy.updateMatrix();
    if(useLight) sandMesh.setMatrixAt(si++,dummy.matrix);
    else sandDarkMesh.setMatrixAt(di++,dummy.matrix);
  }
  sandMesh.count=si; sandDarkMesh.count=di;
  sandMesh.instanceMatrix.needsUpdate=sandDarkMesh.instanceMatrix.needsUpdate=true;
  scene.add(sandMesh,sandDarkMesh);
}


createKoiFish();

// Sand banks on exposed water cells
// â”€â”€ Small decorative pond â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createPond(cx,cz,radius=3.5){
  const y=getGroundHeight(cx,cz);
  const waterMat=new THREE.MeshStandardMaterial({color:'#4a90c0',emissive:'#1a4a70',emissiveIntensity:.5,roughness:.08,metalness:.3,transparent:true,opacity:.85});
  const stoneMat=new THREE.MeshStandardMaterial({color:'#7a7268',roughness:.97});
  const mossMat =new THREE.MeshStandardMaterial({color:'#3a5e28',roughness:.95});
  const sandMat =new THREE.MeshStandardMaterial({color:'#b8a070',roughness:.98});

  // Sunken pond floor â€” slightly below ground
  const floor=new THREE.Mesh(new THREE.CylinderGeometry(radius*.9,radius*.9,.15,18),sandMat);
  floor.position.set(cx,y-.3,cz); floor.receiveShadow=true; scene.add(floor);

  // Water surface
  const water=new THREE.Mesh(new THREE.CircleGeometry(radius*.88,20),waterMat);
  water.rotation.x=-Math.PI/2; water.position.set(cx,y+.05,cz); scene.add(water);

  // Ring of irregular stones around edge
  const stoneCount=Math.round(radius*5);
  for(let i=0;i<stoneCount;i++){
    const a=(i/stoneCount)*Math.PI*2 + (Math.random()-.5)*.3;
    const r=radius+Math.random()*.4;
    const sx=cx+Math.cos(a)*r, sz=cz+Math.sin(a)*r;
    const stone=new THREE.Mesh(
      new THREE.BoxGeometry(.4+Math.random()*.4, .2+Math.random()*.18, .35+Math.random()*.3),
      i%3===0?mossMat:stoneMat
    );
    stone.position.set(sx,y+.08,sz);
    stone.rotation.y=a+Math.random()*.5;
    stone.castShadow=stone.receiveShadow=true; scene.add(stone);
  }

  // A few lily pads on the water surface
  const padMat=new THREE.MeshStandardMaterial({color:'#2d6a2d',roughness:.85,side:THREE.DoubleSide});
  const flowerMat=new THREE.MeshStandardMaterial({color:'#ffaacc',emissive:'#ff8899',emissiveIntensity:.4});
  for(let i=0;i<4;i++){
    const a=Math.random()*Math.PI*2, pr=Math.random()*(radius*.7);
    const pad=new THREE.Mesh(new THREE.CircleGeometry(.4+Math.random()*.2,8),padMat);
    pad.rotation.x=-Math.PI/2; pad.position.set(cx+Math.cos(a)*pr,y+.07,cz+Math.sin(a)*pr);
    scene.add(pad);
    // Tiny flower on some pads
    if(Math.random()>.5){
      const flower=new THREE.Mesh(new THREE.SphereGeometry(.08,5,4),flowerMat);
      flower.position.set(cx+Math.cos(a)*pr,y+.18,cz+Math.sin(a)*pr); scene.add(flower);
    }
  }

  // Bamboo ring â€” 7 stalks loosely around the pond
  const bambooMat=new THREE.MeshStandardMaterial({color:'#5a8a2a',roughness:.8});
  const leafMat  =new THREE.MeshStandardMaterial({color:'#3a6818',roughness:.9,side:THREE.DoubleSide});
  for(let i=0;i<7;i++){
    const a=(i/7)*Math.PI*2+(Math.random()-.5)*.5;
    const br=radius+1.2+Math.random()*1.2;
    const bx=cx+Math.cos(a)*br, bz=cz+Math.sin(a)*br;
    const by=getGroundHeight(bx,bz);
    const h=4+Math.random()*3;
    const stalk=new THREE.Mesh(new THREE.CylinderGeometry(.07,.09,h,6),bambooMat);
    stalk.position.set(bx,by+h/2,bz);
    stalk.rotation.set((Math.random()-.5)*.08,Math.random()*Math.PI,(Math.random()-.5)*.06);
    stalk.castShadow=true; scene.add(stalk);
    // Node rings
    const nodes=Math.floor(h/1.2);
    for(let n=1;n<nodes;n++){
      const node=new THREE.Mesh(new THREE.CylinderGeometry(.1,.1,.1,6),bambooMat);
      node.position.set(bx,by+n*1.2,bz); scene.add(node);
    }
    // Leaf cluster at top
    for(let l=0;l<3;l++){
      const leaf=new THREE.Mesh(new THREE.PlaneGeometry(.25,.9),leafMat);
      leaf.position.set(bx+(Math.random()-.5)*.5,by+h-.5+Math.random()*.4,bz+(Math.random()-.5)*.5);
      leaf.rotation.set(-Math.PI*.3+Math.random()*.3,Math.random()*Math.PI,Math.random()*.3);
      scene.add(leaf);
    }
  }
}



// Stone well â€” clear area south slope
createWell(-8, -14);

// Firepit on the sanded low area (inner water-exposed flat)
createFirepit(-12, 2);

// Dock on southeast shore, angle outward from island centre
createDock(24, -20, 2.3);

// Hanging lanterns â€” peak torii to pagoda, and shrine approach
createLanternString(3,0, 0,16, 5, 7);
createLanternString(-14,10, -18,14, 3, 6);

// Moss ruins â€” outer slopes
createRuins(-24, 2, 4);
createRuins(10, -18, 3);

// Small pond with bamboo â€” northwest extremity
createPond(-22, 18, 3.2);

// Candle groups â€” shrine, pagoda area, well, southeast slope
placeCandleGroup(-18, 14, 3, 1.2);
placeCandleGroup(0, 16, 4, 1.8);
placeCandleGroup(-8, -14, 3, 2.0);
placeCandleGroup(12, -8, 2, 1.0);


createFlowerPatch(22, 8, 65);

// Cat cushion â€” placed at the cushion sit-spot
createCatCushion(16, 18);

createFrog();
createCat();

// â”€â”€ New features â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Sakura petals near blossom tree clusters
createPetalSystem(14, 18, 60);   // east blossom grove
createPetalSystem(-6, 10, 45);   // central area

// Kitsune fox â€” beside the north shrine steps, facing inward
createKitsune(-16, 12, Math.PI*.15);

// Stepping stone bridge â€” crosses the widest low water indent (north side)
createSteppingStoneBridge(-8, 6, -2, 6);

// Windchime â€” hanging near pagoda entrance
createWindchime(1.5, 13.5, 5.5);

// Weather
initWeather();



// Resize â€” debounced so browser zoom (Ctrl+scroll) doesn't fire 60 updates
let _resizeTimer=null;
function onResize(){
  const w=window.innerWidth, h=window.innerHeight;
  camera.aspect=w/h; camera.updateProjectionMatrix();
  renderer.setPixelRatio(Math.min(window.devicePixelRatio,1.5));
  renderer.setSize(w,h);
  labelRenderer.setSize(w,h);
}
window.addEventListener('resize',()=>{ clearTimeout(_resizeTimer); _resizeTimer=setTimeout(onResize,100); });

// Prevent browser Ctrl+scroll page-zoom â€” let OrbitControls handle all wheel events
window.addEventListener('wheel', e=>{ if(e.ctrlKey) e.preventDefault(); }, {passive:false});

applyTimeOfDay();
setInterval(applyTimeOfDay,60000);
loadSaved(); // restore persisted tasks
animate();
</script>
</body>
</html>
